{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"pages/Git.html":{"url":"pages/Git.html","title":"Git","keywords":"","body":" 1.1 关于版本控制 版本控制，是记录文件内容变化，并提供增、删、改、查和回溯等功能的系统 版本控制系统（VCS） 分为：本地VCS、集中VSC、分布式VCS 最简单的版本控制，就是一个版本，一个目录，但这样很蠢，容易出很多问题， 本地VCS（如RCS），利用硬盘上保存“补丁集”的办法记录文件的变化，通过所有补丁可以计算出各个版本的内容 本地VCS只能供自己使用（或只能供本台机器使用，或拥有一个磁盘的机器使用），如果想要多个开发者协同工作，那就需要一个集中式的VCS（如CVS、Subversion、Perforce等），集中式VCS使用单一的一个服务器，保存所有文件的修订版本，所有协作者通过客户端连接到服务器。 集中式VCS最大的缺点就是服务器的单点故障，在恢复之前不能进行协作开发工作，如果服务器磁盘故障，那么整个项目的变更历史都将消失，各个客户端只保存了单独的快照 于是分布式VCS出现了（如Git、Mercurial、Bazaar、Darcs），它不只提取最新版本的快照，而是克隆代码仓，这样服务器有问题，就可以使用任意一个客户端恢复。 分布式VCS还有许多新的优势 1.2Git简史 1991年~2002年，在Linux内核开发过程中，绝大多数的内核维护工作都花在了提交补丁和保存归档的繁琐事物上，到2002年项目组开始使用BitKeeper的VCS来维护。 到了2005年，开发BitKeeper的公司同Linux内核开源社区合作关系结束，自此开始收费，这迫使Linux torvalds 基于BitKeeper的使用教训，开发出了自己的VCS，并对其定制了若干目标： ①速度 ②简单的设计 ③对非线性开发模式的强力支持（允许成千上万个并行开发分支） ④完全分布式 ⑤有能力管理类似Linux内核一样的超大规模项目（速度和数据量） 子2005年以来，git日渐成熟完善，并应用到无数的项目当中。 1.3GIT基础 git对待数据像“快照流”， 注意：快照技术，不同于备份。理解了快照技术，就理解了GIT的基本思想。 次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件 git不是一个简单的VCS，更像是一个小型的文件管理系统 相比其他VCS，git几乎所有的操作都在本地完成，因为本地拥有项目的完整历史，因此速度极其快 没有网络时可以愉快的编写项目，直到有网络再上传，这样的操作在其它VCS是不存在的 git存储和提取版本使用校验和算法（SHA-1），以保证完整性 1.4命令行 1.5安装 1.6配置 初次运行git前的配置：git config，操作gitconfig文件，来设置控制git外观和行为的配置 gitconfig存在/ect/gitconfig中、对应git config --system 选项，表示本机全局 ~/.gitconfig 或~/.config/git/config，对应git config --global，表示本机当前用户 .git/config ，表示本机该仓库 每一个级别可以覆盖上一个级别的配置 用户信息配置： git config [--system/--global/无] user.name “xxx” git config [--system/--global/无] user.email “xxxx” git config --list 列出所有git能找到的配置s git config 列出某一个配置，如git config user.name 2.1 获取GIT仓库 1.对现有项目管理，在项目目录使用git init 2.从服务器克隆：git clone 。如git clone https://github.com/libgit2/libgit2，则本地出现libgit2目录，如果想重新指定仓库名：git clone [name]，如git clone https://github.com/libgit2/libgti2 mylib git支持http https和SSH协议 2.2 命令和几个区域 git status git add 文件，以开始跟踪这个文件 跟踪区域分为：未跟踪区、跟踪区、不跟踪区 未跟踪区到跟踪区，使用git add +文件，反之使用git checkout +文件 不跟踪的，添加到.gitignore文件中 git add是一个多功能命令，1是可以添加跟踪文件，2是如果修改了已跟踪的文件，那么需要再次add一下，来暂存更新，如果不运行这一次add，那么下一步进行提交时，就没有这部分修改更新，换句话说，add的作用是为了提交做准备。 文件 .gitignore 的格式规范如下： 所有空行或者以 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 git diff 查看尚未暂存的改动， git diff --cache git difftool 可以调用插件 以图形化方式对比差异 git commit 存储快照！核心的一步，这就在git中增加了一个版本 git commit -m指定信息 如果直接使用git commit，将调用git指定的编辑器，来指定提交信息 git config ... core.editor 命令可以指定编辑器 git commit -a 可以跳过暂存，即不必add之后再commit git rm可以从已跟踪文件清单中移除文件，并连带从工作目录删除该文件，如果只想从清单中移除，而不想删除文件，使用git rm --cache。 如果删除之前，该文件修改过，还没有放入暂存区，则需要使用git rm -f 来删除，这是安全机制，避免没有形成快照的文件被删除，因为这样的数据不能被恢复。 git mv == mv A B, git rm A, git add B git log 查看提交历史，使用-p参数可以查看每次提交的内容差异，使用-n指定数字可以查看最近n次的内容，--stat显示简略信息，使用--prettye=子选项，可以显示不同格式信息，子选项有oneline、short、full、fuller、format等等。使用--graph可以显示使用ASCII字符模拟的图形 还有其他更多选项 撤销操作： git commit --amend 可以修改最近一次的提交信息 git reset HEAD +文件，是git add的逆操作 对git add之后的文件做了修改，要丢弃这部分修改使用git checkout -- +文件，该命令不可逆 1.6.1 一. 简介 Git（Global Information Tracker，全局信息追踪器）是一款免费、开源的分布式-版本控制系统（VCS），由Linus Torvalds创建（2005.04上线），最初用于管理Linux内核开发。因其性能优异，现已成为主流的分布式VCS。 Git官网：https://git-scm.com/；可在线安装：“#yum install git”；也可通过下载源码编译安装，源码下载地址：https://www.kernel.org/pub/software/scm/git/，其编译安装方式同通用步骤：“#configure && make && make install”；注：Git源码依赖Python、libcurl、perl、zlib、ssh等众多库。 https://git-scm.com/book 二.入门 a)创建版本库 新建一个空目录，或在你的工程顶级目录运行“#git init”，则创建了一个Git版本库，库名为隐藏目录“.git”，以下称“.git”目录为版本库。 b)添加文件 Git只对版本库内的文件负责，而不监测除版本库以外的任何目录。可以通过“#git add xxx”命令将项目文件添加到版本库，xxx可以是当前目录或其它目录下的一个或若干个文件。 使用git status可以查看当前版本库状态 git rm --cached ...\" 以取消暂存 add命令是暂存操作，Git将xxx文件暂存，暂存的目的是为避免项目文件的频发变化，可以多次添加，一次性提交，可以理解为add命令是将项目文件添加到缓冲区。 使用“git commit -m \"t1\" --author=\"zi 303683086@qq.com\"”命令，可将缓冲区的文件提交到版本库，-m和--author必须使用，-m是提交的备注信息，--author指定作者，格式必须为“Name ”，如果提示地址有问题，则可以通过配置文件永久指定地址或通过全局参数“--global”：“vim xxx/.git/config”修改name和email。或“git config --global user.name=’xxx@yyy.com’ && git config --global user.name ‘NAME’”也可以使用全局变量：“GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL”，上述两种方式是全局设置，可以通过不指定--global来本地生效。 -m 选项也可以通过环境变量配置，使每次提交时自动打开一个编辑器编写备注：“export GIT_EDITOR=vim”，这样只需运行命令“git commit”就会打开vim编辑器，按提示编写备注，保存退出即提交成功。 此时运行“git status”显示工作区干净的提示。 对xxx文件简单的修改，此时不必再运行add命令，直接可以commit提交，因为该文件已经提交到版本库，版本库已经对该文件建立了索引，但这次提交需要指定文件名：“git commit xxx” 两次提交之后，版本库中已经有两个版本的xxx了。 git log 可查看提交历史，从最早陈列一个简易列表，每次提交历史都包含一个“commit !@#$2341”，这是由Git产生的提交码，唯一指定提交历史，使用：“git show !@#$2341”，可显示当次提交的详细信息。如果不指定提交码则显示最近一次的提交历史。 使用git diff xxx yyy，（xxx yyy为提交码）可对比两次提交历史。 一种说法：注：git版本库中t版本库中存储每一提交文件的修改，而不存储文件本身（第一次提交存储全部内容）。git记录了每一次的修改内容，给每一次的修改记录索引，通过索引可以寻找和回滚历史版本。 有了Git，就不需要其它命令行工具来管理项目，比如要从项目中删除一个文件，则执行：“#git rm xxx”（前提是该文件已经提交到版本库），这样既从项目目录删除了xxx文件，又从版本库中删除了xxx文件。 删除之后同样要进行提交“#git commit”这样才能最终实现变更。 “git mv xxx yyy”命令可实现版本库文件的重命名，然后记得进行提交操作。 通过git clone 命令可以克隆任一版本库 git配置文件：git配置文件已.ini结尾，它们记录了Git命令使用的各种选项和设置，有些设置是个人偏好，有些设置是版本库正常运作的必须，三个位置存有git配置文件：“.git/config ~/.gitconfig /etc/gitconfig”，优先级按先后生效。也可以通过git config 或 git config --global临时生效。使用git config -l 列出所有配置文件的信息。可以使用git config --unset 或 git config --unset --global 来移除设置。 c) 三. 文件： 1.git 配置文件 分别在/etc/gitconfig ~/.gitconfig .git/config 对应命令：git config --system , git config --global, git config 2.忽略检测文件 touch .gitignore, 支持glob匹配模式，注释用# 3.重命名git mv x y= mv x y, git rm x, git add y mkdir src; git mv x src;git commit(新建文件夹并移动) 4.日志git log、git log -p、git log -p -2、git log --stat git log --pretty=oline/short/full/fuller/format/ git log --pretty=oline/format --graph git log + git show (+SHA-1) 5.git 中任何提交(commit)的都是可以恢复的 当多人在一个文件中协同作业时，提交自己的代码 到远程仓可能失败，是否失败取决于你是否是团队 第一次提交这次作业源码的人，如果不是，就要pull 一次，以更新团队代码到自己的源码中，然后在push checkout 用于从（本地）库 中恢复之前提交过的某一节 点文件（包含删除的文件） git remote show origin git remote rename xx git remote rm git push origin master account:xyZaki password:umbrellxxxx 【设置密码，免推送输入：echo https://xyZaki:umbrellaxxx@github.com > ~/.git-credentials；vim ~/.gitconfig , 输入[credential] helper = store】 git reset 重置分支到某一次commit的指针 --soft 只重置，不做指针破坏 --hard 删除重置后，从重置点到最芯一次commit的指针, git checkout -- + 文件 恢复文件（加--是为了避免分支名与文件名冲突） git checkout + 分支 切换分支 git branch newb 创建分支 git checkout newb 切换分支 git checkout -b newb 等于上述2条命令 git merge SOMEBRANCH 合并其它分支到当前分支，以更新当前文件 补丁操作： 创建补丁：git format-patch -N （N表示创建几个PATCH（从最后一次提交计算），结果是每次提交的补丁） 补丁用于给它人使用，以更新数据（推测可能不具备克隆的条件时使用） 应用补丁：git am（应用补丁并提交） /git apply（应用补丁不自动提交） 分支：git的分支，仅在本地分支、自己使用，是没有意义的。分支应该用于开发协作，分支应该起始于远程仓中（或由本地管理者本地建立后推送至远程仓） --- 分支与切换、存储问题实例：PSCC31项目需新增1.32版本，但又需要保留之前的1.31版本，所以新增分支V1.32 git branch V1.32 //新建分支V1.32 git checkout V1.32 //切换到新的分支 然后修改了一些（已经存在的）文件 修改之后，此时想回到master分支修改一些东西， git checkout master 但发现在V1.32里面修改的内容，也在master分支上同步了 原因是，在新的分支修改完内容之后，需要git add . & git commit -m “xxx” 再切换，内容才不同步， 但是，我现在又不想对新的分支进行提交， 那么就需要暂存起来：git stash 再切换到master，内容就不会同步了， 在master操作完成之后，要切回V1.32，把暂存的内容调出来继续编写 git checkout V1.32 git stash list //查看暂存列表，因为可能暂存多次 //类似这样：statsh{0}: WIP on V1.32:dca0dd7 ..... git stash applay stats{0}//这样就调出了指定的暂存内容 刚刚进行stash的时候，没有起名字，如果stash了多次，怎么才能调用出自己想要的呢？ 那就是要起名字：git stash save xxxx 使用 git stash pop 可以调用最近一次stash的内容 使用git stash clear 清空所有stash 使用 git stash show 可以查看stash的修改 ==================================================================== "},"pages/C++.html":{"url":"pages/C++.html","title":"C++","keywords":"","body":"Jim C++ Catalog 一. 简介     C++起源于贝尔实验室，从C派生、与C兼容、编译时绑定。C++融合了POP、OOP和泛型编程（模板）等编程方式，使用 类 和 对象 来描述数据，强调数据的表达方式，具有封装、继承、多态、异常处理等特性。    附：C++之父Bjarne Stroustrup的个人主页。     二. 抽象     “抽象指从具体事物中被抽取出来的相对独立的各个方面、属性、关系等。” -- 《辞海》。C++的抽象是通过“类”来表示一类实物的共有属性，是泛型编程的基本思想。    类的本质是操作受限的结构变体，对象是结构体变量，关键词class和struct在C++中等效。类的成员分为属性（变量/数据等）和方法（函数/行为/动作/功能等）。     语法：class/struct CLASS_NAME{...attribute list AND function list...};     传统结构体的使用方式是类的使用方式的子集，类还具有方法成员和权限控制能力。 三. 封装     C++类的成员具有访问限制：Private（私有，默认）、Protected（保护）、Public（公有）。 封装方式访问限制 Public无 Protected类、友元函数、派生类 Private类、友元函数     一般将数据成员设计为私有、方法成员设计为公有，仅对派生类开放的成员设计为保护类型。类的对象通过公有或保护方法来操作私有数据。C++将结构体扩展成类，具备类的所有特性，但默认访问限制为公有。     语法：class/struct CLASS_NAME{... pulic:... protected:... private:...};     C++类的特殊方法成员可以在对象创建、复制和销毁时被系统自动调用：构造函数、拷贝构造函数和析构函数。     1. 构造函数与创建对象     构造函数是类中与类同名的公有方法成员，可缺省、可重载、无返回值，在对象被创建（于堆或栈）时由系统自动调用，常用于初始化属性成员和自定义初始动作。     语法：class/struct CLASS_NAME{... pulic: CLASS_NAME(Param list){...};};     → 创建对象的方法：     + 栈中：class/struct CLASS_NAME            OBJ ;    + 堆中：class/struct CLASS_NAME *Pobj = new OBJ ;     默认构造函数形参为空，创建对象时未传参则调用默认构造函数。     2. 拷贝构造与复制对象     拷贝构造函数是构造函数的特例，本质是构造函数的重载，含一个类引用形参，在对象被复制时由系统自动调用，用于处理因对象复制可能导致的内存泄露、重叠等问题。    原则上凡是包含堆和指针成员的类都应该提供拷贝构造函数并合理重载“=”运算符。对象复制发生于三种情形：向函数形参传递对象值、从函数返回对象值、对象赋值。     语法：class/struct CLASS_NAME{... pulic: CLASS_NAME(CLASS_NAME &){...};};     → 浅拷贝与深拷贝：    浅拷贝又称位拷贝，同普通变量赋值，即将A的内存空间数据按位复制到B。缺省的拷贝构造函数和未重载的“=”运算符都为浅拷贝。    当类中存在指针时，如使用浅拷贝，对象A和B的指针成员将指向同一内存空间而导致内存重叠，如果指针指向堆，则在对象销毁时该空间会被释放两次，深拷贝需要设计拷贝构造函数，使对象复制发生时完全拷贝内存镜像。     3. 析构函数与销毁对象     析构函数是类中与类同名的、带有“~”前缀的公有方法成员，可缺省、不可重载、无参、无返回值，可手动调用或在对象被销毁（于堆或栈）时由系统自动调用，常用于释放空间和自定义结束动作。     语法：class/struct CLASS_NAME{... pulic: ~CLASS_NAME(){...};};     → 销毁对象的方法：     + 栈中：栈中的对象在其所在作用域结束时自动销毁    + 堆中：delete Pobj;     4. 友元函数和友元类     友元是类外的、可以访问该类中所有成员的函数或类，称友元函数和友元类，使用friend关键词声明。友元关系是单向的，不具有传递性且不能被继承。友元破坏了类的封装性又适当的打破了封装的局限性，使编程更加灵活。     语法：class/struct CLASS_NAME{... friend R_TYPE FUN(...); ...friend class CLASS_NAME;}; 四. 继承     继承是C++代码重用和功能扩展的重要机制子类（派生类）通过继承父类（超类、基类）来重用、实现和扩展父类的功能，并可多重继承，是自下而上的过程。     语法：class/struct CLASS_NAME : WAY CLASS_B, WAY CLASS_C, ...{...};     WAY表示Public、Protected和Private继承方式，用于限制子类对父类成员的访问权限。 继承方式 父类成员 publicprotectedprivate publicpublicprotected不可见 Protectedprotectedprotected不可见 Privateprivateprivate不可见     父类私有成员总是对子类不可见的，父类公有成员限制随继承方式改变，父类保护成员仅在私有继承时改变访问限制。在内存分配上，子类深拷贝了父类Public和Protected成员。     构造、拷贝构造和析构函数不能被继承，子类构造对象时先调用父类（默认）构造函数，并可指定形参以调用父类重载的构造函数。子类拷贝对象时先调用父类拷贝构造函数、析构对象时反之。     1. 多继承与二义性     一个子类可继承于多个父类（一般多继承），当不同的父类中拥有同名（和同参）成员，且子类可访问时，则可能产生二义性。消除一般多继承二义性的方法是子类重载或重写父类二义性成员或调用父类二义性成员时指明作用域“::”。     2. 虚继承与二义性     在一般多继承情形下，如果不同的父类继承于同一个超类（菱形多继承）且子类可访问时，则可能产生二义性。消除菱形多继承二义性也可通过消除一般多继承二义性的方法，或使用虚继承，即超类在派生父类时使用关键字“virtual”。     语法：class/struct CLASS_PARENT : virtual WAY CLASS_Base, ...{...}; 五. 多态     C++继承衍生了多态特性，继承于同一父类的不同子类通过重写父类的（纯）虚函数来实现不同功能的方式称为多态，是自下而上的过程。     1. 静态联编     函数重载（和操作符重载）是实现静态联编的主要方式。在编译阶段，编译器会根据重载函数参数类型和个数的不同而生成不同的符号列表，从而形成可根据不同参数类型和个数来调用的同名函数。     → 函数重载     在同一个作用域中声明的具有相同函数名而不同参数个数和（或）类型的函数，称为函数重载（与返回值无关）。     附：默认形参与二义性    C++允许在定义函数时指定形参默认值，顺序必须从右向左，调用函数时可以从右向左省略形参以使用默认形参。如果带有默认形参的函数又被重载，则调用时必须指定足够个数的参数以避免二义性。     语法：R_TYPE FUN_NAME (Param1, Param2=N, Param3=M, ...){...};     → 函数重写（覆盖）     派生类会覆盖基类中与基类同名、同参函数，如需调用基类函数，则需使用作用域“::”。     → 运算符重载     重载的运算符表现为由关键字operator指定的、以运算符为函数名的函数，重载的运算符必须是有效的C++运算符（附录D），参数个数必须与运算符操作数相等，且至少一个属于复合类型（class/struct/enum）。     运算符将表达式中的第一个操作数作为第一个形参，第二个操作数作为第二个形参。操作符重载可以定义在类的内外，当在类中定义时，第一个形参省略，默认为所在类的类类型。运算符“=”必须在类中定义。     语法：R_TYPE operator 操作符([class/struct/enum] NAME [OPT *指针, &引用, ...], ...){...};     C++只检测形参的合法性，不检测函数内部实现机制，也不要求返回值，但重载的功能应该符合原运算符的语法规则、属性和优先级。合理的返回值设计也方便参与连续的链式运算。     2. 动态联编     动态联编是C++多态的主要实现方式，它通过虚函数与虚类、纯虚函数与抽象类在运行而非编译时确定接口的实现。     → 虚函数与虚基类     将基类函数声明为虚函数，通过派生类的重写即可实现运行时多态，包含虚函数的类称为虚基类。声明成虚函数的意义在于对内存模型的建立（虚表），从而可用基类的指针通过赋值不同的派生类对象地址来实现不同的功能。     语法：class/struct CLASS_NAME{public/protected: virtual R_TYPE FUN_NAME(...){...}; ...};     构造、拷贝构造与析构函数是否声明为虚函数与虚函数表技术有关，参看附录E。     → 纯虚函数与抽象类     纯虚函数只有声明没有实现，也不能实例化对象，所有的实现都交给派生类，包含纯虚函数的类称为抽象类。抽象类的派生类必须实现抽象类中所有的纯虚函数，抽象类表现为一个行为接口。     语法：class/struct CLASS_NAME{public/protected: virtual R_TYPE FUN_NAME(...)=0; ...}; 六. 模板     模板是C++泛型编程的基础，可以独立于任何特定变量类型的方式编写代码，包含函数模板和类模板。在设计函数和类时可以在任何关于变量类型的地方设置模板（T），在使用时可以指定任意类型变量以实现泛型编程。     语法：template class CLASS_NAME{}; / ... FUN_NAME(...){}    备注：模板函数的形参必须包含所定义的所有模板，不要求返回值。模板在类中可自由定义     STL（Standard template library）     标准模板库由HP实验室研发，现已成为C++标准。STL包含大量数据结构和算法的类模板，并将数据结构和算法分离。     STL包含三种类型代码：容器（Containers）、算法（Algorithms）和迭代器（iterators）；容器是抽象数据类型的模板实现（模板类），即数据结构，如动态数组、列表、队栈、图等。算法用于操作容器（模板函数），如增、删、改、查等。迭代器（又称游标）用于遍历容器，如递增、递减、定位等。     容器类中的方法是针对特定的数据结构而设计的，更多使用的是非成员方法（即算法）来操作容器。特别的，容器类中存在与算法同名的方法，原因是相比通用算法其执行更有效率。     模板使得算法独立于特定的数据类型，迭代器使得算法独立于使用的容器类型。 七. 异常     C++异常是处理程序错误的重要机制，不同于传统C的返回值判定、信号、断言、错误编号、跳转等处理方式，异常处理可获得更详细和精准的信息并将问题检测和问题处理分离，通过关键字$\\color{#FF0000}{try}$检查异常、throw抛出异常、catch捕获异常，如果抛出异常后未进行捕获，则程序将被终止。     语法：CODEBLOCK{throw [expression]}; try{CODEBLOCK}catch(exception param list){...}...catch(...){...}     try-catch语句可以（在try代码块中）嵌套，catch列表及外层catch列表中至少要有一个形参匹配所抛出的异常量类型，否则发生异常时程序将被终止。可在列表最后设置catch(...)以匹配任何异常类型。     将嵌套内层捕获到的异常再抛出（到嵌套外层）的方法是再次利用throw语句，但表达式为空。 一般当嵌套内层无法处理某些异常时会利用该方法。     备注：throw语句将终止执行后续指令、expression可以是任何表达式语句      在函数声明和定义时可使用关键词noexcept修饰以说明该函数不会抛出异常，如果该函数仍然抛出异常，则程序将被终止。这种机制可有效阻止异常的扩散。     语法：R_TYPE FUN_NAME(...) noexcept {...}     → 标准异常     C++内置多个标准异常类，所有异常类都包含what()方法用以描述异常信息。其中exception是所有标准异常类的父类（详见附录F），可以通过继承标准异常来扩展异常。 附录 D 不可重载运算符 运算符描述 .成员访问运算符 .*, ->*成员指针访问运算符 ::域运算符 sizeof- ?:- #预处理符号 附录 E 虚函数表与指针     编译器会为虚基类（和抽象类，下同）中的虚函数建立虚函数表（V-Table），虚函数表是一个数组，数组元素是按虚函数声明顺序排列的、指向各虚函数的指针（_vptr）。     虚基类及其派生类都使用一个指针空间（前4Byte或8Byte）来存放虚函数表指针，虚基类每实例化一个对象，就为该对象添加一个虚函数表指针，对于多重继承的类就添加多个虚函数表指针。一个类的所有对象都共享同一个虚函数表。          派生类继承虚基类的同时继承其虚函数表，派生类的虚函数指针列表存放于虚基类的虚函数指针列表之后，当派生类重写某个虚函数时，就将虚函数表中虚基类的虚函数地址覆盖掉。          → 虚析构函数与内存泄漏     当虚基类的指针指向派生类的对象实现多态时，销毁基类指针时系统只能调用基类析构函数而不会调用派生类的析构函数，从而可能产生内存泄漏。通过将基类析构函数声明为虚函数，在销毁基类指针时还会调用派生类的析构函数。     → 虚基类成本分析     TBD 一.C++抽象 (1)this指针 对象的地址向成员函数的传递是编译器自动完成的，方式是作为成员函数的第一个隐含形参，这个形参就是this指针。this指针属于类，指向被实例化的对象。 通过*this/this可返回对象/对象地址，常用于避免成员变量与形参同名产生的歧义。 (2)静态成员 类中的静态成员是受限于类作用域的static类型的变量和函数，不属于任何对象，不占用对象空间，也没有this指针，静态函数只能访问静态变量。 访问静态成员的方法是直接使用类作用域“::”，类中一切不需要实例化就可以确定行为方式的函数都应该设计为静态的。 类的静态变量必须在类外、main函数之前初始化，且需指定类并省略static关键字。 -临时匿名对象 class a{ a(){}; a(int i){...} }; a(); //临时匿名对象，调用后马上又被析构 a(1); //临时匿名对象，调用后马上又被析构 a(aa) //相当于 class a aa; class a aa; aa = a(); //临时匿名对象，但对象又被接管，这不会调用拷贝构造，并且临时构造对象不会马上被析构 --组合：一个类包含另一个类的对象（以其它类的对象为成员） C++ 11 关键词auto新解： 原auto被使用频率很小，所以C++11将auto赋予新的含义，即具有自动推导功能，这就导致使用auto的同时必须被初始化，也就导致auto不能做形参： auto a = 1; int b = 10; auto a = b; vector c; auto a = c.begin(); 如此这般，auto变量会因赋值类型而自动推导。 附录A. C++命名空间与作用域 namespace SPC_NAME{...}; using namespace SPC_NAME; using SPC_NAME; C语言定义了三类作用域：文件、函数和复合语句，C++增加了类作用域“::”和命名空间作用域，命名空间将同名全局作用域的函数和变量分离，使程序扩展更加便捷。命名空间可以嵌套，使用命名空间通过using关键字或直接限定前缀SPC_NAME::X。 C++标准命名空间为“std”，标准库无“.h”或“.hpp”结尾的头文件均包含于标准命名空间中。参考命名空间实例：c++_link\\namespace.cpp 附录C. C++引用 var_type &quote = var；var_type &fun(...var_type &); 引用是变量的别名，类似Unix系统下的软链接，不占存储空间，向函数传参和作为返回值时相比传值、传址（指针）具有较高的效率和安全性。引用的声明和定义必须同时完成，一旦定义就不能重复绑定。 附录D. C++向C兼容 extern “C”{C function declare list}; 在C++出现之前已有大量的C源码，为向下兼容，C++允许与C代码混合编程，方法是使用关键字extern“C”限制于C函数声明列表。 在编写C程序时，为了方便向上兼容可对C函数声明列表设定宏开关：c++ link\\extern C.h。 附录H. C++资源 项目 地址/名称 描述 网址 C++ FAQ C++常见问题 网址 Free Country 免费的C++库，涵盖压缩、存档、游戏、GUI等编程 网址 C and C++ Users Group 免费C++库，涵盖AI、动画、加密、数据库等编程 书籍 Essential C++ - 书籍 C++ Primer Plus - 附录I. C++标准异常 std::exception 所有标准 C++ 异常的父类 std::bad_alloc 通过 new 抛出 std::bad_cast 通过 dynamic_cast 抛出 std::bad_exception 处理 C++ 程序中无法预期的异常时非常有用 std::bad_typeid 通过 typeid 抛出 std::logic_error 理论上可以通过读取代码来检测到的异常 std::domain_error 当使用了一个无效的数学域时，会抛出该异常 std::invalid_argument 当使用了无效的参数时，会抛出该异常 std::length_error 当创建了太长的 std::string 时，会抛出该异常 std::out_of_range 通过std::vector 、 std::bitset<>::operator等抛出 std::runtime_error 理论上不可以通过读取代码来检测到的异常 std::overflow_error 当发生数学上溢时，会抛出该异常。 std::range_error 当尝试存储超出范围的值时，会抛出该异常。 std::underflow_error 当发生数学下溢时，会抛出该异常 附录I. C++标准与头文件 ANSI 与ISO 于1998年通过C++98标准， 03年更新标准为C++03，该标准只修正了C++98标准的错误，因此用C++98表示 C++98/C++03。2011年通过了C++11标准，该标准较C++98增加了众多特性，同时还提供了C++标准类库。 C++标准规定标准类库使用无后缀的头文件以区别传统C格式和自定的头文件，C++保留了C的头文件并增加了从C转换后的无后缀头文件（eg： => ），所有无后缀的头文件都支持命名空间。 附录J. C++ new与delete C++使用new和delete开辟和销毁堆空间，与C中的malloc和free的使用方式类似，本质上是对malloc和free的封装。 noexcept可有效阻止异常的传播与扩散 include "},"pages/Communication.html":{"url":"pages/Communication.html","title":"Serial Communication","keywords":"","body":"CATALOG 一. 串行通信基础 1 异步串行通信 1 同步串行通信 1 主从串行通信 2 二. 串行通信线路 2 单工通信 2 半双工通信 2 全双工通信 3 三. 串行通信协议 3 UART 3 (1) UART组成 4 (2) RS232 4 (3) RS422 5 (4) RS485 6 SPI 6 IIC 7 //TBD 7 附录A：奇偶校验（Parity check） 8 附录B：波特率与比特率 9 附录C：握手（流控） 10 附录D：RS232接口标准 11 附录E：UART转RS232（DB9） 12 附录F：UART转RS422 13 附录G：共模抑制 14 一.串行通信基础 计算机的数据传输有并行和串行两种方式，并行传输的特点是每个数据位都使用独立的数据线同步传输，传输速度快、效率高，缺点是长距离传输成本高且存在电磁干扰，因此常用于短距离的计算机内部数据传输。 串行数据传输的特点是所有数据位都通过一根数据线传输，速度相对较慢，但传输距离远（几十米到上千米）、成本低，是网络通信、处理器与外设通信的主要方式。串行通信按时序分为同步和异步两种方式，按控制规则分为一主多从和多主多从两种方式。 并行接口一定都是同步的，因为为了高速，不会向异步传输那样增加很多校验位，同时 显然 就必须增加一根时钟线，传输的高速特性也同时限制了传输长度 1.异步串行通信 异步串行通信是以数据帧为单位的间歇传输形式，通过插入标志位来实现数据收发双方的协调。数据帧中包含起始位、数据位、奇偶校验位和停止位。起始位（1位）用于标志传输开始、数据位为5~9位、奇偶校验位用于数据有效性检查（见附录A）、停止位（1/1.5/2位）用于标志数据传输已结束。 上图方框部分表示该数据位可能是高电平“1”，也可能是低电平“0”，每一位都有固定的时间宽度，称为位时间。“MARK”表示空闲时高电平，SPACE表示有效电平，这两个术语可以追溯到二十世纪六十年代。 异步串行通信可以是连续的：上一帧的停止位之后立即发送下一帧的起始位；也可以是断续的，新的数据帧可以在任何时刻开始，并不要求整数倍的位时间。 2.同步串行通信 同步串行通信将传输数据按相等的时间间隔划分成数据帧进行传输，并同时发出同步信号以保证收发同步，每个数据帧的开始用同步字符来标志。 同步串行通信要求收发双方的时钟信号（频率、相位等）必须始终同步，且每个数据帧之间不能有间隔，如果线路空闲或没有数据传输，则需发送同步字符串。 同步串行通信的特点是传输效率高，其数据帧大小几乎不受限制（可达几十到几千字节），但因对时钟同步的要求导致硬件实现成本较高，所以同步串行通信一般用于数据量大、对速度要求较高的串行通信场景。 同步串行通信就是在异步串行通信的基础上加了一条时钟线， 其实这就是SPI总线 3.主从串行通信 在主从通信系统中至少有一个为主机，并允许有多个主机和多个从机。主机负责发送时钟和仲裁（如片选、广播）信号，从机通过总线仲裁来判定是否与主机通信。 二.串行通信线路 串行通信线路包括单工通信、半双工通信和全双工通信，同步和异步串行通信都可以使用这几种形式： 1.单工通信 单工（Simplex）形式使用一根数据线进行数据的单向传输，通信双方固定一端为发送端，另一端为接收端。 例如，计算机与打印机之间的串行通信就是单工形式，只能有计算机向打印机传输数据，而不能有反向数据。 2.半双工通信 半双工（Harf-duplex）形式的数据传输是双向的，但任何时刻只能由其中一方发送数据，另一方接收数据。半双工形式既可以使用一根数据线，也可以使用两根数据线。下图为一根数据线示例。 3.全双工通信 全双工（Full-duplex）形式的数据传输是双向的，可以同时发送和接收数据，因此全双工形式的串行通信需要两条数据线。 三.串行通信协议 串行通信协议包含对接口电气属性的定义、电路结构及线路连接方式的实现、数据传输性能和传输方式的描述等等，所以也称串行通信协议为串行通信接口或串行通信总线。 在现代MCU内部，基本都集成了一个或多个（相同和不同的）串行通信总线，通过配置寄存器即可实现协议所定义的功能。 1.UART UART（Universal Asynchronous Reciver/Transmitter），通用异步接收器/发送器，也称异步通信接口适配器（ACIA）。UART是最简单的串行通信实现方式。UART出现在电子通信早期，当时是一个由齿轮、继电器和电动机械寄存器组成的机械设备。 一般MCU都集成USART（通用同步和异步接收器/发送器），它可以实现UART和USRT（通用同步接收器/发送器）功能，但在单片机的串行通信中，最常用的是异步方式，因此常把USART写为UART。 异步模式的UART不分主从机，在发送数据的同时可以接收数据。如果在同步模式下，则当使用外部时钟时，UART处于从机地位，当使用内部时钟时，UART处于主机地位。 (1)UART组成 UART由发送缓冲寄存器、接收缓冲寄存器和输入移位寄存器组成，发送缓冲寄存器的本质是一个移位寄存器，它将计算机内的并行数据转换为串行数据，并按配置插入标志位形成数据帧，然后通过Tx接口输出。 接收缓冲寄存器和输入移位寄存器组成双缓冲结构，以避免在数据接收过程中出现数据帧重叠错误。输入移位寄存器将Rx接口输入的串行数据过滤，并转换成并行数据，然后存入接收缓冲寄存器，计算机通过读取接收缓冲寄存器来获得数据。 (2)RS232 RS-232C（简称RS232）是古老的串行通信接口标准，可追溯到20世纪60年代，现在正逐渐被高速网络取代，但它对嵌入式系统来说仍然是一种非常重要、简单而有用的连接工具。RS232通信距离可达25米，传输速度可达38.4kbps。 RS232最开始被用来连接数据终端设备（DTE）和数据通信设备（DCE），因此RS232协议标准默认其一端连接的是DTE，另一端连接的是DCE。在计算机出现之前，DTE是一种电传打字机，DCE是一种调制解调器： 当计算机出现以后，刚开始没有更多的可靠通信接口可选用，于是RS232被应用到计算机当中（计算机既可以作为DTE设备也可以作为DCE设备），并一直沿用到现在。RS232使用DB9（D型9引脚接口）或DB25（D型25引脚接口）作为连接接口，其标准定义参看附录D。 如果单片机与计算机通信则必须将单片机看成DTE或DCE设备，此时需要将单片机UART接口改装成DB9或DB25，然后使用RS232与计算机进行通信。需要注意的是单片机使用的TTL电平与RS232电平不一致，需要进行电平转换（参看附录E）： 当使用UART在两个单片机之间通信时只需对接Tx和Rx接口即可： (3)RS422 RS232传输的数据位的电压电平是相对于本地的地，这种不平衡的传输方式有很差抗噪性。RS422使用双绞线传输数据（见附录G），传输距离可达1200m，双绞线电压差在4V~12V之间，该电压差值范围刚好在RS232逻辑电平范围之内，如果将RS422双绞线中负电压一端接地，则可实现与RS232兼容。（RS422与UART的连接参看附录F）。 注意，RS422只规定了标准电压，而没有像RS232一样规定插脚引线等实现细节，所以RS422的具体实现是未定义的，它可以按照实现者的想法自由连接。 (4)RS485 有些RS422的接口芯片具有三态功能，当RS422使用这种芯片实现时就扩展成为RS485。RS485可以实现高效率、低成本的一主多从式多机通信，并支持许多通信协议。它是最简单和最容易实现的网络之一。 如图，主机和从机之间使用一根双绞线进行通信，所有事务都有主机来初始化，从机只有在接收到特定命令后才进行传输。 2.SPI SPI（Serial Peripheral Interface）串行外围设备接口，是由Motorola公司开发的同步、全双工、一主多从式串行通信总线，常用于微控制器与其外围设备的连接。 (1)SPI组成 SPI有4根信号线：MOSI/SI/SDI（Master Out Slave In）、MISO/SO（Master In Slave Out）、SCLK/SCK、SS/CS。大多数处理器的SPI模块带有片选接口，如果需连接多个从机，则需要使用GPIO。 SPI主机和从机都包含一个（8bit）串行移位寄存器，主机通过写寄存器来通过MOSI信号线发起一次传输，从机同步的将寄存器中的数据通过MISO信号线返回。如果主机仅进行写操作，则忽略收到的字节（数据）即可，如果主机要读取从机一个字节，就必须发送一个空字节来引发从机的传输。 如果主机发送连续的数据流时，有些外设（如存储器）可以进行多字节传输，在这种传输模式下，从机必须在整个传输过程中保持低电平。 (2)SPI时序 根据时钟极性和时钟相位的不同，SPI有四个工作模式以适配不同外设的时序和数据处理需求。时钟极性（CPOL）表示时钟空闲时的状态，时钟相位（CPHA）表示数据采样时的有效性。 当时钟相位为0、时钟极性为低电平时，MISO和MOSI在SCK的上升沿有效。 当时钟相位为0、时钟极性为高电平时，MISO和MOSI在SCK的下降沿有效。 当时钟相位为1、时钟极性为低电平时，MISO和MOSI在SCK的下降沿有效。 当时钟相位为1、时钟极性为高电平时，MISO和MOSI在SCK的上升沿有效。 (3)SPI速度 官方标准没有规定SPI的传输速率，目前已知器件可达Mbps水平。 3.IIC IIC（Inter Integrated Circuit Bus，I2C、I2C、TWI）总线是飞利浦公司（Pilips）开发的同步、半双工、多主多从式串行通信总线，常用于微控制器与其外围设备的连接。 (1)IIC组成 IIC只有2根信号线：SDA串行数据线和SCL串行时钟线；两根线接上拉电阻或正极电源，挂载到IIC总线的（N个）设备通过寻址识别，每个器件都可作为主/从设备，但任何时刻只能有一个主控设备。 (2)IIC速度 IIC标准规定标准速度为100Kbps、快速400Kbps、高速3.4Mbps。 TBD... 2.总线协议 IIC总线有三种信号和两种状态：开始信号、应答信号、停止信号、总线空闲、总线忙碌 附：SDA、SCL默认置高电平状态 开始信号：SCL保持高电平，SDA出现下降沿，表示数据开始传输 应答信号：接收设备收到8bit数据之后，发送一个ACK位给发送设备，且每 8bit数据之后必须有一个应答位 停止信号：SCL保持高电平，SDA出现上升沿，表示数据停止传输 总线空闲：SCL和SDA都处于高电平状态 总线忙碌：开始信号之后，停止信号之前 3.传输格式 IIC总线的传输格式为主从式：主发送从接收、从发送主接收 ·主发送从接收模式 主设备开始信号之后，发送第一个字节为控制字节（从到地址到低地址 = 7位地址寻址位 + 1位方向位，方向位决定主设备是从从设备读数据还是向从设备写数据，为0时表示写、1时表示读），接下来发送数据，该数据可以是一个或N个字节，从设备每接到1个字节都要返回一个应答信号（ACK = 0），主设备在应答时钟周期为高电平时释放SDA，转由从设备控制（发送应答信号），从设备在这个时钟周期的高电平期间必须拉低SDA，并使之为稳定低电平，以作为有效的应答信号 ·从发送主接收模式 仍然从主设备开始信号，主设备向IIC总线发送控制字节（“广播”），从设备进行地址位比对，之后检查控制字节的第8位是1/0，当为1时，表示主控设备要读数据，此时从设备先发送一个应答信号（ACK = 0）给主设备，接着发送数据到主设备，同样的主设备收到一个字节（8bit）后，也要发送一个应答信号给从设备，不同的是如果这个ACK = 0（有效应答信号）那么从设备继续发送数据，如果ACK = 1（停止应答信号）则从设备停止发送数据。主设备也可以控制从设备从什么地址开始发送数据（默认从设备从主设备发送过来的控制字节地址发送数据），发送多少字节 基本操作 IIC总线是主/从双向通信，主设备和从设备都可以发送和接收，但总线必须由主设备控制，主设备产生串行时钟SCL，并产生开始和停止条件，在开始条件之后SDA线上的数据状态仅在SCL为低电平期间内才能改变，在SCL高电平期间SDA上的数据改变用来表示开始和停止条件 ·控制字节 在开始条件之后，第一个字节必须是控制字节，其中高4位是器件类型标识符（不同器件有不同的意义：如EEPROM为1010），接着3位为片选（这意味着同一器件不能超过8个），最低位为读写控制为，即1 - 读/0 - 写 5.总线仲裁 wating... 6.IO模拟 如果单片机带有IIC总线接口（高级单片机一般都带有若干个），则直接挂载设备即可，如果没有，则可以使用普通IO口模拟 ·硬件上 硬件上只需两个GPIO引脚，一个作为串行时钟线SCL，一个作为串行数据线SDA，并且都挂接到上拉电阻或正极电源 ·软件上 软件上要严格模拟IIC总线数据传输规则，示例： 子程序如下： ORG 1000HBSEND: MOV R2, #08H ; 1字节8位 SENDA: CLR P3.2 ; SCL置低 RLC A ; 左移一位 MOV P3.3, C ; 写一位 SETB P3.2 ; SCL置高 DJNZ R2, SENDA ; 写完8个字节？ CLR P3.2 ; 应答信号 SETB P3.3 ; SDA置高 SETB P3.2 ; SCL置低 RETEND 附：MSB与LSB MSB：Most Significant Bit，最高有效位，在时序图中表示高字节先发送或表示最高位，在二进制数中表示最高加权位，位于数据位最左侧 LSB： Least Significant Bit，最低有效位，在时序图中表示低字节先发送或表示最低位，在二进制数中表示最低加权位，位于数据位最右侧 附录A：奇偶校验（Parity check） 奇偶校验是验证数据传输有效性的简单验证方式。一串二进制数据帧，其中“1”的个数只有两种可能：奇数或偶数。 奇校验（ODD CHECK），就是将该数据帧添加一位“0”或“1”，使得新的数据帧中“1”的个数为奇数，新添加的二进制位就是校验位，接收方收到数据后，再次对原数据帧进行奇校验，对比添加的校验位是否一致，如果一致就说明数据完好。 偶校验（EVEN CHECK），就是将该数据帧添加一位“0”或“1”，使得新的数据帧中“1”的个数为偶数，新添加的二进制位就是校验位，接收方收到数据后，再次对原数据进行偶校验，对比添加的校验位是否一致，如果一致就说明数据完好。 奇偶校验，是轻量级数据校验方式，它只适用于数据受干扰较小的情景，如果数据受干扰较大，则二进制数据帧有可能有偶数个数据位变化，导致最后校验结果无误，但实际数据已经损坏。 附录B：波特率与比特率 比特率是指每秒钟传输或处理比特（bit）或位的数量，单位为“bps或bit/s（Bit Per Second）”，常用于计算机通信领域。比特率的单位是千进制：1Kbit/s = 1000bit/s、1Mbit/s = 1000Kbit/s、1Gbit/s = 1000Mbit/s。 每秒1次的信号变化为1波特（baud），原用于表示电信设备传输速率，现用于调制解调器的数据传输速率。波特率是指每秒钟传输符号的数量，单位是波特。通过不同的信号调制方式，可以在一个符号上负载多个比特信息，当调试方式是二进制调制时，波特率与比特率的值一致，单位可使用“bps”等。 附录C：握手（流控） 当两个系统进行串行通信时，在接收者处理完接收数据之前，必须禁止发送者发送新的数据，这个过程称为握手（shake hands）或流控（flow control），握手有三种方式：软件方式、硬件方式、不握手。 不握手是最简单的方式，用于发送系统在准备和发送数据上都比接收系统慢得多的场合，比如1MHz的低速单片机发送给1GHz的高速单片机，或者手工向计算机输入数据。注意，当接收端使用高速处理器，但使用了实时反映能力较弱的操作系统，则也有可能需要握手。 硬件握手方式在不同的硬件中有不同的实现方式，以RS232为例，它使用两个信号：RTS（请求发送）和CTS（清除发送），当发送者希望发送数据时就置RTS有效，高速接收者有数据等待发送，而当接收者准备就绪时就将CTS置为有效，来通知发送者可以发送数据。 软件握手用于无法实现硬件握手的场景。软件握手用两个字符来实现流控，一个代表请求对方暂停传输、另一个代表清除暂停传输的请求，继续传输数据。通常这个两个字符是Ctrl-S（0X13）和Ctrl-Q（0X11）。 附录D：RS232接口（母口）标准 信号 功能 DB25 DB9 方向 Tx 发送数据 2 2 DTE-DCE Rx 接收数据 3 3 DTE-DCE RTS 请求发送 4 7 DTE-DCE CTS 清除发送 5 8 DTE-DCE DTR 数据终端就绪 20 4 DTE-DCE DSR 数据设备就绪 6 6 DTE-DCE DCD 数据载波检测 8 1 DTE-DCE RI 振铃指示器 22 1 DTE-DCE FG 侦测地（机壳） 1 - 共用 SG 信号地 7 5 共用 注：① DB25和DB9接口呈“D”型，它们又被称为COM口；② 这些信号中许多都是用来对调试解调器进行控制器的，如果要在一台计算机和一个终端之间建立一个很简单的链接，仅需Tx和Rx信号就够了。另外，许多系统都将FG和SG连接到一起。 附录E：UART转RS232（DB9） TTL逻辑高电平为：输出 - >2.4V，输入 - >2.0V；逻辑低电平为：输出 - MAX232支持两个输入输出端口：T1IN、T2IN、T1OUT、T2OUT、R1IN、R2IN、R1OUT、R2OUT；通过附录D可知，DB9第2和3针为Rx、Tx，第5针为SG信号地（必要）： 注：① DB9有公头和母头之分，它们的引脚顺序定义不同，且母头的第一引脚在右上角（倒梯形时），其它引脚依次向左排列；② 没有用到的接口，可以用作嵌入式系统的电源线；③ 与PC通信时，波特率不宜设置太高，以免有乱码出现。 附录F：UART转RS422 MAX3488是一款用于RS422电平转换的芯片，同RS232一样，其Tx和Rx接口可直接与UART相连： 上图中Rt是一个终止电阻，用来消除信号反射，信号反射发生在远距离传输过程中，并且是远距离传输所必须的。Rt的标准阻值是100~120Ω。 附录G：共模抑制 用两根线之间的电压差来代表逻辑电平，这两根线称为双绞线或差分对（different pair），两个信号振幅相等、相位相反，当出现噪声时，双绞线同时受到干扰，于是两根线之间的电压差几乎没有变化，这种现象又称为共模抑制。 "},"pages/Qt.html":{"url":"pages/Qt.html","title":"Qt","keywords":"","body":"1.μC-GUI与emWin μC-GUI和emWin都是嵌入式系统图形库，emWin由Segger公司研发，μC-GUI是Segger面向Micrium公司的定制产品，两款产品资料通用，但拥有各自的使用许可条文。 2.μC-GUI Micrium公司的所有产品，在任何商业应用条件下都不是免费的，并且对所有产品拥有统一的在商业中使用的许可条文： ①单一产品许可：需指定CPU型号，最终产品名称，没有数量和时间限制 ②产品线许可：无需指定CPU型号，需指定最终产品名称 ③CPU类型（平台）许可：只需指定CPU型号，可以生产各种产品 ④站点许可：只需指定站点，CPU、最终产品名称和数量都没有限制 价格表（Micrium中国总代 - 北京麦克泰软件技术有限公司，μC-GUI报价）： 类型 价格（元） 时间 单一产品许可 RMB130,000 永久 产品线许可 RMB650,000 永久 CPU类型（平台）许可 RMB845,000 永久 站点许可 - - 3.emWin Segger公司的产品，在商业应用条件下有免费使用方式： ① Segger公司提供定制服务，定制公司用于产品最终解释权，如Segger向ST公司定制STemWin，则使用含有STemWin库的ST芯片时无需支付库的使用费用；而Segger向Micrium公司定制μC-GUI，但使用μC-GUI时需要遵循Micrium公司许可条款。 ② Segger公司提供合作机制，如Segger与NXP公司合作，凡使用NXP芯片的用户，都可以免费使用emWin库（信息来源：https://www.nxp.com/pages/emwin-graphics-library:EMWIN-GRAPHICS-LIBRARY）。 附录A：Micrium 总部（美）联系方式 ·电话：1-954-217-2036 ·传真：1-954-217-2037 ·邮箱： 销售邮箱：sales@micrium.com 信息咨询：info@micrium.com ·官网：https://www.micrium.com/ "},"pages/Bootloader.html":{"url":"pages/Bootloader.html","title":"Bootloader","keywords":"","body":"uboot简介 uboot是GNU开源、嵌入式领域的Bootloader，用于初始化硬件和加载内核（加载模式），并提供基础命令行环境以调试硬件和下载程序（开发模式）。 官网：http://www.denx.de；（下载）ftp://ftp.denx.de/pub/u-boot/。 uboot分析 1.版本分析 uboot分为官网版本、Soc厂商版本和第三方版本。 官网uboot每年约2~3个月发布一个版本，到2017年为止大约有70个版本，可分为三个阶段：初阶段版本-2010.6（不含）之前的版本，中阶段版本-2010.6~2014.10（不含）之间的版本，现阶段版本-2014.10以后的版本。各版本间主要有以下变化： 版本号变化：2008年8月以前的版本按版本号命名，其后按年份命名 目录树变化：第一次从u-boot-1.3.2版本增加了“api”目录，第二次从2010.6版 本合并了“cpu”与“lib_xxx”目录到“arch”目录，并分离出通用的“lib”目录。 配置的变化：从2014.10版本开始支持图形界面配置“$make menuconfig” Soc厂商uboot从官网uboot移植以支持其Soc和核心PCB，第三方一般是PCB底板厂商，其uboot从Soc厂商移植以支持其底板PCB。 2.目录分析 u-boot-2019.07版本uboot有1630个目录、21757个文件，其主要目录结构及含义如下： 附：参考目录树，u-boot-2019.07版本示例 ├── api Machine/arch independent API for external apps [用于外部应用程序的独立于机器/架构的API] ├── arch Architecture specific files ├── board Board dependent files ├── cmd U-Boot commands functions ├── common Miscellaneous architecture independent functions [混杂的独立于体系结构的功能] ├── configs Board default configuration files ├── disk Code for disk drive partition handling ├── doc ├── Documentation ├── drivers Commonly used device drivers ├── dts Contains Makefile for building internal U-Boot fdt [flatted device tree - 设备扁平树] ├── env├── examples ├── fs Filesystem code (cramfs, ext2, jffs2, etc.) ├── include Header Files ├── lib Library routines generic to all architectures [所有体系结构通用的库例程] ├── Licenses ├── net Networking code ├── post Power On Self Test ├── scripts Various build scripts and Makefiles ├── test └── tools Tools to build S-Record or U-Boot images, etc 3.编译原理 uboot编译依赖于Makefile技术。在u-boot-2014.10版本之前，编译主要依赖顶层目录的“Makefile”、“config.mk”及各子孙目录的“Makefile”文件。在u-boot-2014.10版本之后，增加了图形界面，其编译除依赖上述文件外还依赖“Kconfig”文件。 //TBD uboot编写 uboot移植 编译 移植的最终目的是生成“uboot.bin”二进制文件，其 //TBD 附录A：BIOS BIOS（Basic Input Output System）基本输入输出系统是固化在ROM芯片内、（PC）上电后执行的第一个程序，用于开机自检（POST）、硬件配置等最底层的硬件控制。 通过BIOS可以指定Bootloader启动介质，从而进一步启动操作系统。嵌入式系统中通常使用简单的拨码方式代替BIOS的该项功能。 附录B：BootLoader Bootloader（启动加载器）是一种引导程序，用于初始化硬件和加载操作系统内核，是计算机上电后执行的第一个或第二个程序（第一个是BIOS）。 Bootloader与硬件相关，因此都集成了很多平台，PC端有适用Linux的Lilo/Grub、适用Windows的NTLDR。嵌入式端有红帽的Redboot、ARM的blob/ARMboot、三星的vivi/Bios-it、GNU的uboot等等。 附录C：uboot（Hush-shell）命令 散装知识点 固件（firmware）：存储于ROM中的（固定或永久性）程序。 "},"pages/PCB.html":{"url":"pages/PCB.html","title":"PCB","keywords":"","body":"1 PCB Foundation 1.1 Concept PCB (Printed Circuit Board) 印制电路板，简称电路板。PCB是电子元器件的电气连接载体和支撑体，在20世纪50年代开始推广，是现代广泛采用的集成电路构建技术。 Tips : Appendix-A Ancient circuit construction mode 1.2 Structure PCB consists of Solder mask, Medium, Copper and Silk layer. 阻焊剂常呈绿色，覆盖于PCB上下表面以阻止被保护电路被焊接，丝印层于阻焊层之上用于描述元件、备注等信息，铜层是PCB的核心，表铜层覆盖于阻焊层之下，内铜层以介质层分隔，各层之间通过过孔通信。 Tips : PCB铜层厚度以盎司Oz为单位，1Oz = 35um，常规规格为1Oz，另有2Oz、3Oz等。介质层由FR-4等级的环氧树脂、玻璃纤维和填充剂复合而成。 1.3 PCB Design Schematic layout and PCB layout are the core of PCB design，schematic uses nets to describe connection of circuit component pins and PCB uses the nets to generate pin-index to guide wiring. Tips : PCB设计的重点是电路和电磁兼容性的设计，本质是对模电、数电和电磁理论的运用。设计软件本身并不重要。 1.3.1 Schematic & symbol Schematic layout is the first step of PCB design and which is consists of symbols and net. symbols are abstractions of components with the same number of pins and nets indicates electrical connection between symbol pins. Symbols are stored in symbol library and can be created in software. Simple design steps in schematic layout : 1-circuit design, 2-select/create symbols, 3-nets connection. Tips : It is feasible to design PCB directly without schematic, but it will make PCB design difficult. In addition, schematic diagram is very important for software engineers 1.3.2 PCB & footprint PCB layout is the second step of PCB design and which is consists of footprint and wiring. footprints are graphical components with accuracy data info (package mode and size, pin spacing and LxWxHxD, etc) and wiring is the realization of (schematic) nets, it's a visible connection on the surface of PCB. Footprints are stored in footprint library and can be created in software. Simple design steps in PCB layout : 1-data set (wire width and spacing, drill diameter and spacing), 2-size and shape design and component palcement, 3-Wiring, 4-copper filled, 5-set origin and auxiliary flags Tips : The placement of components directly affects the difficulty of wiring that use layers and drills (note : both sides can be used). 1.3.2.1 Layer The concept of 'layers' in software is not exactly the same as that actual PCB and there are different names and types in different software and some layers are not real layers, such as 'mechanical layer' in Altium Designer and 'graphic x' in KICAD, all of these layers are auxiliary. Only silk, solder mask and copper layers are unified and correspond to reality one by one. Copper layers can be used as signal, GND or PWR, common design scheme as below : layer Nu copper scheme 1 scheme 2 scheme 3 1 F.Cu MIX - - 2 F.Cu MIX SIG+PWR GND B.Cu MIX GND SIG+PWR 4 F.Cu SIG SIG PWR In1.Cu PWR GND SIG In2.Cu GND PWR SIG B.Cu SIG SIG GND 8 F.Cu SIG SIG SIG In1.Cu GND SIG GND In2.Cu SIG GND PWR In3.Cu GND SIG SIG In4.Cu PWR SIG SIG In5.Cu SIG PWR GND In6.Cu GND SIG PWR B.Cu SIG SIG SIG Tips : Power layer can mix signal wire if necessary, but try to keep GND layer clean. 1.3.2.2 Drilling Drilling is the electrical hub between PCB layers, including Through, Blind, Buried and Macro type. 1.3.2.3 NetList Netlist is a text file with the content about 'nets' generated by the schematic automatically, it's also the hub for transition from schematic to PCB layout. 1.3.2.4 Copper filled Copper filling objects are GND, PWR and other special nets on EACH LAYER to reduce the loop area and improve PCB performance. Copper filled comparison of 4 layers PCB Tips : Island copper filling is not allowed, connect to GND if it exist, otherwise, some unpredictable problems MAY arise. Note : Dense drilling affect the effect of copper filling. 1.3.3 Gerber, BOM and Drill Files Gerber is an international standard format for describe PCB images, which provides data for each process of PCB maker. Drill files is extracted from Gerber for describe position, size and type of drillings. BOM-Bill of Material for describe PCB components and properties. Tips : *.pcb file can be provided directly to PCB maker, but some unpredictable problems MAY arise. 1.4 PCB standard IPC standard is an international PCB standard about the whole life cycle of PCB. Official website IPC standards tree 2 PCB Electromagnetic compatibility 2.1 Concept EMC (Electromagnetic compatibility) 电磁兼容性，用于描述设备或系统在电磁环境中抵抗干扰 (EMS-Electromagnetic susceptibility 电磁耐受性) 和释放干扰 (EMI-Electromagnetic interference 电磁干扰) 的特性. 2.2 Source 分布式电容、分布式电感、脉冲噪声、PCB天线、静电等辐射发射和传导发射源是电磁干扰的主要来源. 分布式电容 : 非电容态的形式电容，PCB上下层和同层导线可能产生的电容效应，影响高频电路。 分布式电感 : 非电感态的形式电感，PCB导线和元件的分布可能产生的电感效应，影响高频电路。 2.3 Tactics Copper filling, GND separation (for signal layer), 3W wiring (for same layer) & 20H, Cross wiring (between layers), Open-loop check, Resonance rules, Short line rules (for special signal, such as clock signal), Power overlap rules, Angle rules (acute and right angle are not allowed), Same type - Same side, Same type - Same layer and Less drilling .etc. 3W and 20H Cross wiring Angle Open-Loop Responance 3 PCB design software 3.1 KICAD 3.2 Altium designer Appendix-A：Ancient circuit construction mode A.1 快速构建 这是一种非常草率的方法，只对构造极其简单的电路原型有用。它通过在任意大小的空间里把元器件焊接在一起来构成非常简单的电路。 如图，将晶体放在处理器上方，晶体引线直接焊接到处理器引脚，其它引线也焊接到处理器引脚来引入电源和接地从而把处理器的I/O和外部连接起来。 A.2 面包板 面包板又称电路实验板，是带有排列孔的塑料/铁/磁块儿，它被设计用来盛放DIP封装（双列直插封装）的集成电路和离散元器件。术语“面包板”可追溯到真空管时代，当时真空管无线电设备是建立在一块用于切面包的结实木板上的，因此得名。 使用面包板也不是搭建健壮可靠系统的方法，面包板限制于过多的电容、串扰及噪声敏感度，长期使用后还有机器故障。面包板上的电路连接是通过一段段小的电线来实现的，而这些电线构成了小的天线，这些小天线会吸收周围零散的电磁辐射从而影响电路。 A.3 绕接技术 绕接曾经是常用的电路构建技术，必须是DIP封装的电路才能使用绕接，它通过约0.6英寸的引脚安装在插座上，然后用绕砸工具（绕砸器和剥线器）在引脚周围绕上电线，这样便构成了一个电路，这也被称为冷焊技术，即不带焊接的一种线与引脚间的紧密电气连接技术。 绕接是一种非常快速的原型技术，且健壮和可靠。在早期，NASA（美国国家航天局）惯于使用绕接技术构建宇宙飞船电子设备，并且许多大型计算机也使用这种技术。 Appendix-B：PCB process B.x 焊接 PCB元件焊接有回流焊和波峰焊两种方法，回流焊是贴片元件焊接的一种低成本方法：将钢网抠刻出与欲焊接的PCB元件的位置和大小相同的区域，然后将PCB与铁网固定并刷锡浆，同时人工放置元件以完成焊接；使用SMT自动贴片机可高效完成贴片元件焊接，但成本较高。波峰焊是插件元件焊接的方法：PCB插装元件后经过锡炉即焊接完成，并通过剪脚机将管脚剪短。 Appendix-C：PCBA and ICT C.1 Concept PCBA（Printed Circuit Board +Assembly）又写作PCB’A，是指对PCB空板的装配过程，也指通过该过程生产的成品印刷电路板。PCBA测试是对完成焊接的PCBA板进行程序烧制和有关通路、环境、电压、电流、压力等方面的测试，是PCBA加工过程中的一个重要环节，处于生产工序的末端，是严控出货品质的重要手段。 C.2 PCBA测试方式及PCBA测试架 小批量生产的PCBA可以借助专业测试设备或手工万用表的方式对测试点检测，对于大批量生产的PCBA测试则要使用测试架（Fixture）来辅助完成。PCBA测试架又称PCBA测试治具，其原理是通过测试顶针与PCB板的测试点连接，从而获取电路中的电压、电流等关键数据，并在测试架的显示屏幕上显示，达到快速检测的目的。客户在设计PCB板时，就应该考虑其测试方案并预留PCB测试点，然后出具专业的测试文档或测试方案给制造商。 制作PCBA测试架要提供的文件。 C.3 测试分类及原理 PCBA测试的方法主要包括：ICT测试、FCT测试、老化测试、疲劳测试、振动测试、高低温测试。 C.3.1 ICT测试 - 导通性测试 ICT (In Circuit Test) 又称在线测试仪，ICT测试主要是通过测试探针接触PCB的测试点 (ICT测试点) 来检测线路的开路、短路以及PCBA板上元器件的焊接情况（不涉及到功能按键或者输入输出方面的测试）。ICT测试具有操作简单、准确性高的特点。一些中低端的PCBA板可专门制作ICT测试治具，可有效的降低测试成本。 C.3.1.1 ICT测试对PCB设计的要求 PCB对角上需设计两个125MILS的非金属化的定位孔，并且每个网络都至少有一个ICT测试点，测试点可以是PCB焊接面的焊点或过孔，检测点的焊盘尺寸最小为24mils (0.6mm)，两个单独测试点的最小间距为60mils (1.5mm)。 C.3.2 FCT测试 - 功能性测试 FCT测试由又可称为PCBA功能测试，是指对目标内部功能的测试，可对测试目标提供模拟的运行环境（激励和负载），使其工作于各种状态之中，以测量输出端的参数是否符合要求。测试的内容主要包括电压、电流、功率、功率因素、频率、占空比、亮度与颜色、字符识别、声音识别、温度测量、压力测量、运动控制、FLASH和EEPROM烧录等。 C.3.3 老化测试 老化测试是指对PCBA板进行长时间的通电，进行输入输出方面的测试，模拟用户的操作，以确保其性能符合市场的要求。 C.3.4 疲劳测试 疲劳测试是指对PCBA进行高频、长时间的操作，观察是否出现失效，判断测试出现故障的概率，以此来检查PCBA板的工作性能。 C.3.5 震动测试 震动测试采用专业的震动测试仪进行长周期测试，确保焊接元件无任何脱落情况出现，抽样测试比例根据客户要求决定。 C.3.5 高温测试 高温测试是指将PCBA放入测试房，并针对性地提供-40℃至100℃等常见温区的测试服务，充分模拟产品的环境温度，最大化确保产品的可靠性。 C.4 PCBA测试材料与价格 C.4.1 测试探针 目前测试探针分国产、台湾香港、进口三种。进口产品一般是德国、美国、日本的产品，品牌有INGUN、TCI、日电、华荣、中探、亚探等。测试探针的质量主要体现在材质、镀层、弹簧、套管的直径精度及制作工艺。目前包括国内的产品其材质很多用进口材质，所以除非是偷工减料一般探针材质问题不是很大，针及套管的直径精度方面国内与台湾香港的产品差不多，进口稍好但一般影响不大，弹簧及镀层的质量这方面进口产品比国内要好很多，台湾香港产的比国内稍好一些，原因主要是工艺水平上的差别，国产的探针镀层抗磨损较差镀层容易脱落。如果制作的测试治具使用时间及测试次数超过15万次以上选用进口产品较为合适，但进口的探针价格较贵。目前国内的制作水平和工艺逐步提高，并且在当前价格大战的情况下，不少代理商用国产针冒充进口或台湾产的探针出售。如果测试要求和测试次数不高的话建议可选用国产探针。探针的质量主要对测试治具制作中的测试次数及接触是否良好有关。 C.4.2 测试线 目前测试线都是国外进口或台湾香港地区生产，其产品的区别不大。价格为约125元一卷。 C.4.3 测试板材 测试治具中所选用的板材一般有压克力（有机玻璃）、环氧树脂板等。普通的探针孔径大于1.00毫米的治具，其板材以有机玻璃居多，有机玻璃价格便宜，同时有机玻璃相对较软钻孔时有胀缩探针套管与孔的结合紧密，由于有机玻璃是透明的治具出现问题检查十分容易。但是普通的有机玻璃在钻孔时容易发生溶化和断钻头，特别是钻孔孔径小于0.8毫米时问题很大，一般钻孔孔径小于1毫米时都采用环氧树脂板材，环氧树脂板材钻孔不容易断钻头其韧性及刚性都好但价格较贵一些，环氧树脂板没有胀缩所以如果钻孔孔径不精确会造成探针套管与孔之间很松动产生晃动。环氧树脂板不透明如果治具出现问题检查较困难一些，另外有机玻璃温差变形比环氧树脂板大一些，如果测试的密度非常高的需采用环氧树脂板。板材的选用及钻孔的精度对整个测试治具的精度起关键的作用。 治具的底座大部份是用PVC或有机玻璃制作的，大部份的厂家制作治具底座时是根据测试板材的大小临时制作的，所以底座的质量及底座的重复使用率不是很好，所以建议统一底座大小及标准，本网站提供二种标准的底座可适用大部份的专用测试机，其材料采用20毫米的有机玻璃，由有机玻璃厂家制作质量及工艺非常好，可重复使用，价格虽然稍贵但物有所值。 Appendix-D：Common component packaging Appendix-E：HUAWEI PCB design specification Standard : China GB/T 4588.3-2002 & IPC-2221 E.1 布局规范 遵照“先大后小，先难后易”的布置原则，即重要的单元电路、核心元器件应当优先布局 IC器件布局时，栅格应为50--100mil. 小型表面安装器件 (如表面贴装元件) 布局时，栅格设置应不少于25mil 同类型插装元器件在X或Y方向上应朝一个方向放置。同一种类型的有极性分立元件也要力争在X或Y方向上保持一致，便于生产和检验。 发热元件要一般应均匀分布，以利于单板和整机的散热，除温度检测元件以外的温度敏感器件应远离发热量大的元器件 元器件的排列要便于调试和维修，如小元件周围不能放置大元件，需调试的元器件周围要有足够的空间 BGA封装元件与相邻元件的距离应>5mm，其它贴片元件相互间的距离>0.7mm。贴装元件焊盘的外侧与相邻插装元件的外侧距离>2mm；有压接件的PCB，压接的接插件周围5mm内不能有插装元、器件，在焊接面其周围5mm内也不能有贴装元、器件 E,2 布线规范 E.2.1 布线优先次序 关键信号线优先：电源、摸拟小信号、高速信号、时钟信号和同步信号等信号优先布线 密度优先原则：从单板上连接关系最复杂的器件着手布线，从单板上连线最密集的区域开始布线 E.2.2 PIN密度与层的关系 PIN密度的定义为 : 板面积（平方英寸）/（板上管脚总数/14） PIN密度 信号层 板层 1.0以上 2 2 0.6-1.0 2 4 0.4-0.6 4 6 0.3-0.4 6 8 0.2-0.3 8 12 10 >14 E.2.3 线宽、线厚与电流的关系 线宽(mm) 铜厚35um 铜厚50um 铜厚70um 电流(A) 0.15 0.20 0.50 0.70 0.20 0.55 0.70 0.90 0.30 0.80 1.10 1.30 0.40 1.10 1.35 1.70 0.50 1.35 1.70 2.00 0.60 1.60 1.90 2.30 0.80 2.00 2.40 2.80 1.00 2.30 2.60 3.20 1.20 2.70 3.00 3.60 1.50 3.20 3.50 4.20 2.00 4.00 4.30 5.10 2.50 4.50 5.10 6.00 E.2.4 线间距与绝缘电压的关系 线间电压(V) 内层线间距(mm) 外层线间距(mm) 5000 11.5 14.5 4000 9 11.4 3000 6.5 8.43 2000 4 5.38 1000 1.5 2.33 500 0.25 0.8 300 0.2 0.4 100 0.1 0.13 0.05 0.1 Tips : 可对绝缘体击穿的电压为绝缘体电压. E.2.5 PCB工艺限制 限制 国内 国际先进水平 推荐最小线宽/间距(mil) 6/6 4/4 极限最小线宽/间距(mil) 4/6 2/2 E.2.6 孔、焊盘与板厚的关系 板厚(mm) 3.0 2.5 2.0 1.6 1.0 最小孔径(mil) 24 20 16 12 8 焊盘直径(mil) 40 35 28 25 20 热焊盘直径(mil) 50 45 40 35 30 "},"pages/Analog.html":{"url":"pages/Analog.html","title":"Analog Elec","keywords":"","body":"concept 模拟电子技术（Analog Electronics Tec.）是以半导体为基础材料、以电荷移动为基本原理的模拟信号放大技术。本质是研究能量的控制，结果是功率（不失真）的放大 电子技术的发展 关键词：电子管-晶体管-集成电路-大规模-超大规模 ---------------------------------------------- 1947 晶体管 - 贝尔实验室 1958 集成电路 1969 大规模集成电路 1975 超大规模集成电路 第一片集成电路只有4个晶体管，1997年有40亿个 预计2020年达饱和 模拟信号与模拟电路 关键词：连续/时间&空间有意义/放大（能量控制）/有源元件/功能和性能(细节)分析 --------------------------------------------------------------------------- 重点：基本概念/基本电路/基本分析方法/全面分析(副作用分析），适用的才是最好的 -------------------------------------------------------------------------- 四个会：会看(读图/分析)/会算/会选(电路 器件 参数)/会调 ----------------------------------------------------- 数字信号：离散性（时间和数值） 模拟信号：连续性（时间和数值），几乎所有物理量都是模拟信号，如温度 压力等，任何瞬间的任何值都有意义 模拟电路：最基本的处理是对信号的放大，放大的本质是能量的控制 传感器/AD转化的信号基本上都是小信号，它们不足以驱动负载/传输/转化，所以要进行放大 有源元件：能够控制能量的元件 常用半导体器件 半导体基础知识 本征半导体 半导体：绝缘体 mid 导体 导体的最外层电子容易脱离原子核束缚（通过电场/温度等）, 最外层电子4 半导体-四价元素，Si Ge，电子被束缚力介于导体与绝缘体之间 最外层电子=4 原子核：正电 电子：负电 关键词：原子结构（核正子负，最外2/8稳定，4为半导体，其它结构易失/得）/Si Ge/本征无杂质-共价键 拓展 : 化学-原子 ---------------- 关键词：少子/多子 载流子 自由电子/空穴 热运动 (绝对温度0度不导电） 拓展：物理 - 热力学 ------------------ 本征半导体受温度影响 自由电子脱离共价键束缚成为自由电子 形成空穴 在温度一定下，自由电子浓度一定 温度升高，热运动加剧 杂质半导体 本征半导体受电场和温度影响，载流子很少，导电性很差 参如3价和5价的元素掺入本征半导体，将改善导电性能 N型半导体：本征加入P磷，破坏共价键，增加一个P就增加一个自由电子，此时自由电子成为多数载流子,空穴为少数 P : B硼, 吸收电子 , 空穴成为多数载流子，自由电子为少数 关键词：5价/P磷/3价/B硼/N型半导体(Negative -)/P型半导体（Positive +） 杂质半导体，仍然受温度变化，但受温度变化自由电子和空穴浓度仍然一定，重要的是在N中空穴比例小，温度变化 后对空穴比例浓度影响最大，P中自由电子比例小，温度变化后自由电子比例浓度影响较大 重点：少数载流子是影响半导体器件温度稳定性的主要因素 关键词：温度/比例浓度 PN结的形成及其单向导电性 在一块本征半导体基片上，做成PN结(两端根据扩散原理掺入不同杂质)，注意，不是将一个P半导体和N半导体按压到一起！！ ,这样它们的交界界面就形成空间电荷区，成为PN结 制作成的PN结，仍然受扩散运动的影响，P区的空穴向N区扩散，N区的自由电子向P区扩散， （实际上空穴是假想，实际是电子运动) NONE P N ----------- | +++++++++ | |-----------| ----------- | +++++++++ | |-----------| ----------- | +++++++++ | |-----------| N区电子运动到P区与空穴复合，因为复合后P区接触面开始带负电，N区开始带正电，导致PN结形成内电场 内电场将组织自由电子的复合，并且反向运动，如此反复以形成稳定的区域 NONE P N ----------- | +++++++++ | |-----------| ----------- | +++++++++ | |-----------| ----------- | +++++++++ | |-----------| 在空间电荷区（接触面）N区的自由电子向 关键词：空间电荷区/PN结-扩散运动-内电场-漂移运动-动态平衡 -------------------------------------------------------- 拓展：物理-热力学 ---------------- 给PN结通电，会打破动态平衡，释加正电压会削弱内电场（耗尽层变窄），进而扩散运动加剧，PN导通 正电压是指P区接正极，N接负极，因为电流的流动实际是电子的移动，即从电池的负极流出电子，而 负极接N区，导致N区电子增多，进而削弱了内电场，最后导通PN结 如果反向给电，效果相反，即电池的电子流向了P区，使得复合了很多空穴，增加了内电场，使得耗尽区变大，PN不通 关键词：外电场/削弱-增强/导通-截止/耗尽区/正向-加剧扩散/反向-加剧漂移 --------------------------------------------------------------------- 拓展：物理 - 电荷运动 -------------------- PN结的电容效应 势垒电容 : PN结外加电压时 空间电荷区宽度变化，有电荷积累和释放过程，与电容充放电向相同，其等效电容为//// 扩散电容： PN结外加正电压时，在扩散过程中在刘子浓度和梯度都有变化，也有电荷累积和释放，其等。。。。 结电容 =势垒电容 + 扩散电容 结电容不是常量，PN结外加电压频率到一定程度将失去单向导电性 关键词：势垒电容 扩散电容 结电容 限制电压频率 总之，pn结的扩散电容与其势垒电容不同。前者是少数载流子引起的电容，对于pn结的开关速度有很大影响，在正偏下起很大作用、在反偏下可以忽略，在低频时很重要、在高频时可以忽略；后者是多数载流子引起的电容，在反偏和正偏时都起作用，并且在低频和高频下都很重要 二极管 单向导通性 伏安特性 非发光二极管在电路中的电压在1V～2V之间，当电流在5～20mA时会发光，否则不发光 发光二极管在电路中的电压为0.7V 当二极管两端的电压小于0.5(约)时不导通，达到O.5V之后导通 当二极管两端电压反向，且大于击穿电压时导通 Tips：伏安特性曲线 ------ 稳压二极管 反向连接，且反向电压大于稳压电压时，该稳压二极管具有稳定电压的作用 Tips：稳压二极管电路 ： 二极管 + 电阻的串连电路 （其中二极管反向连接） 稳压二极管利用了二极管的伏安特性中的反向性质：当反向电流达到一定值时，（反向）电压是稳定的。 要注意的是，反向电流一定在Max和Min之间，Min是二极管反向时刚刚导通时的电流，Max是二极管刚好击穿时的电流 Tips : 两种稳压电路的区别（二极管+电阻 VS 电阻+二极管） 整流二极管 用于将交流电变成（脉动）直流电 利用到了二极管的单向导通特性 当交流电的正弦波通过二极管时，每个正弦波的180～360度的相位被过滤掉，即变成了脉动直流电 开关二极管 利用到了二极管的单向导通特性 这种二极管比普通二极管的开关速度快（即 导通-截止 状态切换快） 用于器件的保护，防止反向电流的通过 散装知识点 去耦电容/退耦电容 位置 ： 放在元器件连接VCC电源之间 和 元器件信号输出端， 去耦电容和旁路电容（放在元器件的信号输入端）相对应 耦合-辞海 : 两个元素/量之间,其中一个量的变化,导致另一个元素/量的变化的一种关系 噪声-辞海 ：信号中 随机变化的 无用的 信号成分。 电路中安装在元件的电源端的电容，此电容可以提供比较稳定的电源，同时也可以降低元件耦合到电源端的噪声，间接可以减少其他元件受此元件噪声的影响 去耦电容，是影响了 电源 和 元件 之间的耦合，滤除了电源上的干扰信号，使电源信号稳定, 继而是连通该电源的元器件用电稳定 Q&A: 为什么要去耦？ A：当一个电源端连接多个元器件供电时，每个元器件的工作都要动态的吸收电流，时多时少，多个元器件一起工作更会影响电源的稳定（直流的波形开起来像交流），这不但会影响元器件的供电， 也会产生电磁噪声影响周围系统，是元器件和周围系统产生错误的信号，所以在电源向元器件的输出端加上一个电容（称为去耦电容），用来减小或消除影响。 B: 当元器件输出信号时 为什么电容能去耦？ 去耦原理 ：因为电容是储能元件，当电压突变高时电容吸收多余电量，当电压突变低时电容释放存储电量补充 选型与放置 基本原则：最小化电阻(ESR)、最小化电感(ESL) 电容还具有阻抗和电感属性，对于电阻而言无论频率如何都呈固定阻抗，对于电感而言随着频率的增加而增强 容量选型： 电容式储能元件，当在电源端用作去耦功能时，还可以实现“蓄能”功能，即用来补偿电源的长期偏差（长期偏差可能是开关电源到PCB电源的距离较远，且负载较大，导致长期供电不足） ，如果需要补偿电源的长期偏差，则需要大量存储电荷，即选择大容量去耦电容 种类选型： 陶瓷电容 具有很小的阻抗和电感，其次是钽电容 ， 另外贴片电容的效果更好 放置 ： 电源 - 去耦电容 - 地，三点一线，呈最佳效果 去耦电容可以并联使用(相同/不同容值)，已达到更好的去耦效果 牛屎芯片/牛屎封装 DICE: DICE 也叫 CHIP 或裸片，是没有封装的芯片 (常见芯片是黑色的矩形外壳，四周或者下面会引出许多金属脚，这种芯片就是标准封装。标准 封装已经规定好引脚的位置和大小，这样进行产品开发时候只要知道用的是什么封装就知道电路板 应该怎么布线) 这种芯片需要通过一种叫 BONDING（邦定）的方法将芯片上的引脚用非常细的线连出来,，再点上胶直接固定在电路板上 另外有的时候担心产品的程序被人复制，这样比用标准封装程序被复制的难度要大许多，标准封装只能依赖单片机 自身的防复制功能和把上面的丝印磨掉不让别人知道是什么型号的单片机来进行 现代诸多电子产品的 PCB 板上看到纽扣大小的黑色芯片,大家管它叫做“牛屎” 。其实它真正的学名叫 做绑定(bonding )，也就是芯片打线,芯片覆膜,音译为邦定， 是“ bonding ”的音译，是芯片生产工艺 中一种打线的方式，一般用于封装前将芯片内部的电路用金线与封装管脚连接。一般 bonding 后(即电路与 管脚连接后)用黑色胶体将芯片封 装, 同时采用的外封装技术 COB(Chip On Board),这种工艺的流程是将 已经测试好的晶圆植入到特制的电路板上， 然后用金线将晶圆电路连接到电路板上，再将融化后具有特 殊保护功能 的有机材料覆盖到晶圆上来完成芯片的后期封装。 使用邦定技术的芯片又叫 “裸芯” ， 即半成品芯片。 由于本身已经具备了最基本的控制功能, 所以在 刚开始使用时与封装芯片并没有什么不同， 但由于省去了很多后续工序， 如没有增加 必要的保护电路，它 的使用寿命与稳定性都要比最终完工的封装 IC 集成芯片低很多，一旦坏了没得维修，一般只有整个报废， 其成本也只有硬封装 IC 集成芯片的 1/2到 1/3。 第一，牛屎芯片的封装工艺环境天生就不够塑料封装好，起码滴胶工艺的净度就绝对比不上正规硬封装厂家 的芯片。 第二，牛屎芯片的缺点，底衬不能很好的焊接或者是焊接不牢靠、受热受潮或者是受冷冻之后底衬可能会接触不 良、黑胶密封性差、对潮湿环境和静电抑制能力差、易老化、损坏无法维修。 第三，牛屎芯片的优点就是开发周期短、封装成本低、适用于比较简单的电路。 第四，同一个等级的芯片，用牛屎封装同用塑料封装，肯定是塑封好。牛屎的故障率肯定比正常的塑料封 装要高 逆变器 逆变器一般有6个功率晶体管（q1~q6）组成，分为上臂/上桥（q1、q2、q3）和下臂/下桥（q4、q5、q6） 它有将直流转换为三相交流 和 控制电流导通的开关功能。 缓冲器 缓冲器分输入缓冲器和输出缓冲器两种。前者的作用是将外设送来的数据暂时存放，以便处理器将它取走，后者的作用是用来暂时存放处理器送往外设的数据。有了数控缓冲器，就可以使高速工作的CPU与慢速工作的外设起协调和缓冲作用，实现数据传送的同步。由于缓冲器接在数据总线上，故必须具有三态输出功能。 74HC244是缓冲器的一种 该芯片用于数据同步以解决MUC与外设速度不匹配的问题，同时增强MCU的负载能力以驱动更多外设，又因其具有三态门，故还有隔离保护功能。 继电器 光电耦合器 optical coupler 简称OC 又叫光电隔离器，简称光耦 它将发光器和受光器封装在一个管壳内，来实现无接触式/绝缘式的 电 - 光 - 电 的转换 发光器通常是一个发光二极管、受光器为一个光敏半导体管 拥有体积小、寿命长、无触点、抗干扰强、输入输出绝缘等优点 MOC3020 是其中一款产品。 触发器 在实际的数字系统中往往包含大量的存储元件， 且经常要求它们同一时刻同步动作，为达到这个目的，在 每个存储单元电路上引入一个时钟脉冲（CLK）作为控制信号，只有CLK到来时电路才被“触发”而动作，并根据输入 信号改变输出状态。 这种在时钟信号触发时才能动作的存储单元电路，称为触发器，以区别没有时钟信号控制的锁存器。 D触发器是触发器的一种，它在时钟脉冲CP的前沿（正跳变0-1）发生翻转。D触发器的应用很广，如数字信号的 寄存、移位寄存、分频和波形发生器等。 74HC574是D触发器中的一种芯片 存储器 KEY: RAM ROM 存储阵列 行列译码 简介 存储器是计算机的数据记忆存储设备，用具有两种稳定状态的物理器件来存储信息（二进制数据）。按存储介质可分为半导体存储器和磁表面存储器，按功能作用可分为主存储器、辅存储器、高速缓冲存储器、控制存储器等。 半导体存储器由半导体芯片制成，可存在于片内（如CPU内部）、片上（板载）或成为独立设备（如内存条），可用作主存储器、高速缓冲存储器和控制存储器，如ROM、RAM、Register，也可用作辅助存储器，如FLASH。磁表面存储器由载体和磁性材料组成，常用作辅助存储器，如磁盘、光盘、磁带等。 半导体存储器 根据摩尔定律，半导体芯片每2~3年革新换代一次，从1970年至今半导体芯片晶体管集成度已达数十亿级别，其中半导体存储器占芯片的大部分面积。主要分为四大类：只读存储器ROM、随机存取存储器RAM、寄存器Register和闪存Flash ROM - Read-Only Memory，只读存储器，又称程序存储器。ROM在制作时或制作后写入数据，在工作时只能进行读操作，断电后数据不丢失，通常只有几十k或几百k的存储容量，常用于存储固件。按制作工艺可分为掩膜ROM-MROM（制作时形成数据）、可编程ROM-PROM（制作后一次性写入）、可擦可编程ROM-EPROM（紫外线照射擦除，可多次写入）、电可擦可编程ROM-EEPROM（电擦除，可多次写入）。 RAM- RAM - Random Access Memory，随机存取存储器，又称数据存储器。RAM可以随机存取，速度快，但断电后数据丢失，通常有几M、几百M或几G的存储容量，用于操作系统下的数据的临时存储。RAM分为静态RAM（Static RAM - SRAM）和动态RAM（Dynamic RAM - DRAM） A: SRAM SRAM分为MOS型SRAM（NMOS、CMOS）和双极型SRAM（TFT），由于SRAM的复杂电路结构，使得成本要比DRAM高很多，而且集成度低，一般只有几十K~几百K或几M存储容量。 SRAM读写速度极快，功耗低，常用作高性能微处理器中的高速缓存（Cache）。SRAM在工作时电路不需要刷新，只要供电就会一直存储数据，断电后数据消失。SRAM由三部分组成：存储单元阵列、（行/列）地址译码器、读写电路。 存储容量常写为乘法形式，如：“2Kx8位”，表示存储容量为16Kbit或2KByte，并可推导该芯片的地址总线数：“2K=2^11，有11根地址总线”；8位表示有8根数据总线，8个存储元视为一个存储单元。同一容量的SRAM有不同的存储实现方式，如：“1Kx16位、2Kx8位、4Kx4位、8Kx2位、16Kx1位等”；并可以是单片形式，或者通过其它存储阵列并联组成。 FLASH 闪存是EEPROM的发展，又兼具RAM的特性，其集成度高、功耗低 、体积小 ，又能在线快速擦除 Flash可归属ROM家族，因其特性单独讨论，安卓手机上常提到的ROM通常指FLASH，而不是MROM、PROM、EPROM或EEPROM等。 EEPROM 及 存储保护 1.软件 A.上电延时 B.存储备份和恢复 2.硬件 A.MCU自带功能,如AVR的BOD功能 B.大电容防止存储掉电 PAGE / BANK PAGE/BANK一般出现在简单的单片机中，PAGE对应于ROM，BANK对应于RAM，作用基本一致 BANK这里当做“储存块”来讲 有些指令只能操作很小的地址范围，通过BANK的方法（通过寄存器配置选中哪一部分来操作）可以将指令寻址大大增加，BANK 也同时增加了程序复杂性 CISC/RISC 复杂指令集与精简指令集 CISC具有大量的指令集，并增加硬件复杂性以满足用户的需求 RISC则反之，只拥有较少的指令，而把复杂性嫁接到软件复杂性上 一般CISC有几百条指令，而RISC只有几十条指令 目前PC机的CPU基本上都还是CISC指令集的， RISC 和CISC 的区别： ①RISC 指令系统较小，种类的数量较少，只提供简单指令。CISC 指令系统大，种类的数量多， 提供各种指令。 ②RISC 指令长度、寻址方式、格式都整齐划一，这样可以充分利用流水线，基本上可实现一个 时钟脉冲执行一条指令。CISC 指令长度、寻址方式、格式不一，难通过流水线方式提升指令执行效 率，无法做到一个时钟脉冲执行一条指令。 ③RISC 的函数调用将现场状况保存在专用寄存器中来提升效率，参数也使用寄存器传递。CISC 的函数调用一般通过堆栈保存现场，需要内存操作，效率要低 专用单片机的辉煌与落寞 冯·诺依曼结构与哈弗结构 冯诺依曼结构（也称普林斯顿结构）是计算机的启蒙结构，也是使用了相当长一段时间、并且现在计算机仍然在采用的计算机体系结构， 冯诺依曼提出 程序（指令）和数据 共用同一组地址总线和数据总线，这样 读取程序代码和数据就不能同步运行 哈弗结构将 程序（指令） 和 数据 分开存储， 使用两条独立的总线，如此哈弗结构单片机片内至少存在4套总线：指令数据总线、指令地址总线、数据的数据总线、数据地址总线 ，显然，哈弗结构可以同时获取指令和数据，互不干扰，效率更高 这就是冯诺依曼结构和哈弗结构的主要区别：哈弗结构少了一次总线切换。 DSP DSP就采用了哈弗结构，但只是采用哈弗结构不能显著提示单片机效率，于是DSP增加了很多硬件设备，如乘法器，对于没有乘法器硬件的单片机来说，实现一个乘法可能需要几十条 、上百条的指令，而有了乘法器，一个指令周期就将乘法搞定。 同时DSP还使用了流水线设计，使得原来的\"取指、译码、执行“三步在一个信号周期内就完成了，即在执行指令的同时对下一条指令译码并同时取得下一条指令，真正的流水线更加复杂 会有很多的优解。 DSP是专门对数字信号处理作出的设计，在处理数字信号时会比冯诺依曼结构快很多，但如果用DSP实现简单的逻辑控制并不一定比冯诺依曼结构快 不是所有的单片机都是冯·诺依曼结构，在移动数字通讯刚刚兴起的年代，DSP 那是望尽春色， 近年来随着技术的发展单片机的速度是越跑越快，有一些单片机也开始采用哈佛结构，少数单片机 内部甚至会加上一个小的DSP 核，使得DSP 在数字处理速度方面的优势逐步变小，加上一些专用器 件内部采用硬内核进行数据处理，这些变化恐怕让DSP 难以再现昔日辉煌。 这不仅仅是DSP的过程，也将是许多专用单片机的故事，将来或者是现在，一个ARM-A9或许可以把所有单片机都替代了 术语 MIPS ： 百万指令每秒 74系列芯片 74系列芯片是TI德州仪器、NXP恩智浦、ST意法半导体等半导体公司生产的中小规模TTL集成电路芯片，主要用于计算机数据的输入、输出、锁存等处理，工作温度在-40~85℃之间。该系列芯片以74开头，连接字母或数字以标识不同功能。 例：74XXX 标准型TTL、电压2.4V、传递延迟9ns、功耗10mW。74LXXX低功耗TTL、电压2.4V、传递延迟33ns、功耗1mW。74HXXX高速型TTL、电压2.4V、传递延迟6ns、功耗23mW。 芯片最后的一个或几个字母，表示封装方式，不同厂家有不同标记方法，一般D表示SOP封装，如74HC138D 74或74+字母之后的数字表示该芯片的逻辑功能，不同的字母，相同的逻辑数字，其逻辑功能一样： 如：74LS224与74HC224的逻辑功能是一样的 附： 秒 1s = 1000ms 毫秒 1ms = 1000us 微秒 1us = 1000ns 纳秒 ADC 简介 ADC（Analog to Digital Converter）也称A/D，即模/数转换器，是将外界连续变化的模拟信号转换为离散的数字信号的电子元件。ADC最早用于无线电台中无线信号向数字信号的转换。与ADC对应的电子元件为DAC数模转换器 分类 有多种ADC类型：并行、逐次逼近型、积分型、∑-Δ型、流水线性，低功耗、高速、高分辨率是ADC的发展方向。其中并行ADC是当今速度较快的模数转换器。 AVRATMEGA128集成逐次逼近型ADC 指标 ADC 采样率和分辨率 是两个重要的参数 分辨率 - 模拟量量化为数字量的精度 - 量化精度（也称ADC精度，位数） 采样率 - 模拟量量化为数字量的速率 - 量化速率（单位SPS，或b/s或Hz） 采样个数/采样时间 - 单位时间内采样个数 显然采样率与分辨率有关，- 分辨率越高，样本数量越大，单位时间内采样数量越大，采样率越高 如果采样率可配置，则分辨率固定的情况下，增大采样率，同一时间内可采样更多样本 采样率是与分辨率有关联的，ADC手册经常看到的参数描述如：\"8位分辨率下采样率79kSPS , 最高分辨率时采样率高达15 kSPS\" 因为采样率表示数字量 ，数字量量化为模拟量的速率 ，ADC精度高，则代表的数值范围越大，数字量变多，所以相同时间内采样速度变慢 所以分辨率越高，采样率越小。它们之间可能没有固定比例关系，应该跟不同的ADC有关。 有些ADC的采样率和分辨率是可配置的。有些则不能，如ATMEGA128，分辨率固定为10位，采样率为15kb/s 采样率与奈奎斯特频率：采样率应至少为采样信号频率的两倍，(从这个角度讲，ATMEGA128不能对信号频率大于7.5kHz的进行采样??), 如果低于这个频率，采样信号失真. 基准电压 基于参考电压来将模拟量转换为数字码，因为数字电路只认高低电平，所以如果没有参考电压ADC读取来的电压值将是无意义的，（数字信号本身不具实际意义，仅表示相对大小1/0）而这参考电压又称基准电压，其指标是温漂，一般用ppm/K表示。 假设ADC的基准电压为5V、输入电压3V，则输入电压/基准电压=60%，对于8位ADC而言，该模拟量代表256X60%=153（0X99）。 公式：Dadc = 2n X ( Vadc / Vref )，其中n为ADC精度。 可见输入电压大于基准电压时ADC达满精度（满量程），输入电压为0V时，ADC为最小精度0。再设计上，基准电压最高值应该等于参考电压，如果基准电压不够，则可以使用功率放大器放大或使用ADC自带的增益。 单端与差分输入通道 单端输入是指被测电压从某个引脚输入，其参考电压是内部电压或GND。差分输入需要两个输入引脚，其参考电压时两个引脚彼此之间的相对电压。其中单端输入方式较为常见。 单端方式适用于传感器到ADC的线距离较短（5m以下），且所有输入信号要共用一个基准地。差分输入适用于更长距离的数据传输，更适用于噪声较大的使用场景。 如图所示，单端输入只有一个输入引脚ADCIN，使用公共地GND作为电路的返回端，ADC的采样值=ADCIN - GND(0V)。这种输入方式优点就是简单，缺点是如果VIN受到干扰，由于GND电位始终是0V，所以最终ADC的采样值也会随着干扰而变化。 而差分输入比单端输入多了一根线，最终的ADC采样值=(ADCIN+) - (ADCIN-)，由于通常这两根差分线会布在一起，所以他们受到的干扰是差不多的，输入共模干扰，在输入ADC时会被减掉，从而降低了干扰，缺点就是接线复杂一些。而且需要VIN+和VIN-两路反相的输入信号。 其它术语参考：https://www.maximintegrated.com/cn/app-notes/index.mvp/id/641 https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E6%95%B8%E4%BD%8D%E8%BD%89%E6%8F%9B%E5%99%A8 ---------------------------实验记录 热敏电阻测温实验， 设置ADC时钟分频为2（CPU时钟16MHz），时钟频率为8MHz，发现Vadc = 4.99，Dadc = 1023。 设置为4分频时，时钟频率 = 4MHz，Vadc和Dadc的值正常。 设置8分频、16、32、64、128分频都正常。 原因未知。 ------------------------------ Other ADC串联电阻的意义：关键词：数字电源、模拟电源、隔离、去耦、ADC性能、数字瞬态电流 TTL与CMOS电平 TTL电平：晶体管-晶体管逻辑电平，是计算机电路中的标准电平，它使用+5v=逻辑1、0V=逻辑0。 TTL与CMOS TTL电路速度快、延迟小、功耗高、抗噪声能力差 CMOS电路速度慢、延迟高、功耗低、抗噪声能力强 TTL电平的实际标准 输出： 高电平 - >2.4V 低电平 - 2.0V 低电平 - 0.7 * Vcc 输出 - >0.9 * Vcc 可见CMOS电平的高低电平取值是依电源电压而定的 ，高电平接近电源电压，低电平接近0 晶振 晶振是单片机系统的指挥家，它发布统一的工作节奏，注意，是统一而不是同一，统一意味着A吹两下笛子，B就得拉四次小提琴，这样不同的乐器 在统一的指挥下才能演奏出动听的交响曲。 晶振 就是 晶体振荡器，或 石英晶体振荡器， 石英这个东西就厉害了，他就是二氧化硅，天下物料之集大成者：玻璃、光纤、玛瑙、水晶、单片机等等。 石英晶体具有压电效应：给晶体薄片施加电场，晶体会形变，当移除电场时，晶体恢复形变并释放电场，如此往复形成固定的震动频率 RC振荡器（电容和电阻组成的振荡器）也可以作为触发信号源，但稳定性比晶振差、如果产品对时间精度要求不严格（比如一种按键发光的儿童玩具）就可以用RC 振荡器来节约成本 选多快的晶振？是不是单片机要跑多快就用多大的晶振？ NO！频率越快，越容易产生电气噪声干扰，越难以控制，并且晶振对电路要求很高（在距离和走线上等等），如果放置不当还不会正常工作。 晶振作为一个外部器件，要提供的频率应该越稳定越好，而不是越快越好，那单片机需要更快的振荡频率怎么办呢？ 这就需要锁相环 PLL 技术来解决，该技术可以将晶振频率加倍（N倍），进而实现更高的振荡频率 另外PLL还具有动态改变工作频率的能力 此外，还有分频器，即将晶振频率(或其它频率)分解的更小来使用 通过上述知识可知，通过晶振振荡可将震动传递给单片机内部，单片机内部可以通过倍频或分频技术来利用，无论倍N频还是分N频，显然都必须具备N是整数 ，通过将外部晶振 倍频和分频得到的震动频率，就是系统时钟 I/O复用技术 为了单片机增加I/O功能，又不能增加I/O管脚数量，只能将IO做成复用的，即一个接口可以有多种功能 不同的功能配置，通过单片机寄存器配置来完成 IO与GPIO IO就是输入输出，在单片机中代表输入输出接口，GPIO是近来兴起的说法，意为“通用IO”，都是一样的，叫法不同而已 上拉电阻 将不确定的信号接口，通过一个电阻拉在高电平，这个电阻就是上拉电阻，电阻同时起到限流的作用 下拉电阻就是将不确定的信号接口，通过一个电阻拉在低电平，这个电阻就是下拉电阻 PWM PWM即脉宽调制，其本质原理是“恒流斩波”：改变负载开关的开关频率或直流电流的接通和通断时间，就可以改变加载到负载上的电压和电流的平均值。从这个意义上说，PWM类似与负载串联的可调电阻。 (具数据统计，使用直流斩波器代替变阻器可节约电能约25%，利用直流斩波原理制作的器件角DC/DC，这一原理还实现了PWM技术。) PWM可以用软件模拟，也可以用硬件实现，在计算机中通常使用定时器来产生PWM。通过软件模拟，即通过延时来调整高低电平的输出时间，进而调整脉宽。脉宽即脉冲宽度，脉冲与脉宽是两个概念。 While(1) { PORTA = 0XFF; DELAY(1); PORTA = 0X00; DELAY(1); } 该代码可产生占空比为50%的方波，占空比表示一个PWM周期内有效电平所占时间与整个周期的比值，有效电平通常指高电平，在一些应用中也可能是低电平。 上述图示PWM占空比为50%，红色部分表示PWM一个周期。 高峰表示Vcc，低谷表示GND 实际产生的电压值为(Vcc - 0v)x50% PWM占空比为100%时的情况，此时负载电压为Vcc，以最高能量工作。 PWM占空比为0%的情况，此时负载电压为0v，不工作。 PWM可以用来驱动电机以，通过调整占空比，进而调整步进电机电压，从而控制其转速。 PWM也可以驱动LED灯，通过调整占空比，进而调整LED电压，让其产生“呼吸”效果。 可见要产生PWM，就必须实现快速的开关通断，这个速度是如此之快，以至于手工和机械都是完成不了的，所以必须使用继承电路IC实现。 PWM作为一种波形，携带这两种信息，一个是脉宽->占空比，另一是频率，前者是主要信息，是PWM的本质，后者是任何波形都携带的信息。脉宽信息决定着实际输出电压，频率信息决定着脉宽信息的改变速度。比如，当PWM用于驱动LED呼吸时，PWM脉宽决定了LED的呼吸（脉宽从0%~100%~0%改变），而PWM频率信息决定了LED的呼吸速度。又比如，当PWM用于驱动电机时，PWM脉宽决定了电机速度，而PWM频率决定了电机切换速度的速度。 附：PWM波是非正玄波，这使得输出的能量不能得到充分利用，于是产生了正玄波脉宽调制SPWM、SVPWM。 附：简易的呼吸灯设计 整个程序分两段，在死循环中，前段为PWM产生代码，后段为闪烁方向设计。闪烁方向设计让呼吸灯从”亮到灭到亮”变化，否则“从亮到灭，从亮到灭”变化。 要注意，上述程序延时使用微秒，而不是毫秒或秒，微秒级别的延时让人的眼睛看不到灯闪烁的过程（为了产生PWM只能让让灯亮灭），这里也利用了人类的视觉暂留原理，实际上灯是在飞速的闪烁，要看到这个效果，只需把微秒改成毫秒即可。 还有，数值一定要连续，才能使PWM模拟从0~5V的持续电压变化，如果给定数组查表，而不是从0累加，那么数组值一定要密集（采样足够多），否则也会产生毫秒级别的闪烁。（也可以理解为，要使尽量使PWM接近正弦波） 最后，改变微秒级别的闪烁值（setTimeCount），就可以改变灯的呼吸速度，从上述程序中也可以看到，一定要保证PWM周期固定，然后改变亮与灭的占空比即可。 附：通过示波器测量，上述程序产生的是方波，PWM本质就是方波，所以测量无误，即便程序模拟使PWM近似正玄波，但结果还是方波。 测量晶振结果为正弦波（晶振产生的是正弦波，通过电路滤波后形成供电路系统使用的方波） PWM恒流斩波效果的实现需要PWM周期足够小 (一般刷新频率子60Hz以上就可以了，这个跟电脑显示器的刷新频率一致，一般PC机显示屏的最低刷新频率是60Hz，即1秒刷新60次[即16.7ms/次]) 如果一定要使用较大周期怎么办呢？ 比如1s为周期可以实现恒流斩波效果 10s呢？ 10s就必须将其均匀化！ 如果在1s时使用的是50%方波，则在10s周期时，每1s都分为两部分，这样10s就被分为20个部分，其中10个部分为50% HIGH level，另外10个部分为50% LOW LEVEL 如此就在比较大的周期中实现PWM效果了！ 如果在1s时实现的是20% · 80% 同样在10s周期中将每1s都实现20%~80% 这样，无论在多长的周期中，都可以实现PWM效果 代码 // 20% 占空比 PWM周期1s delay(0.2) PORTA = 0X00; delay(0.8) PORTA = 0XFF; // 20% 占空比 PWM周期5s 1s均化 for(int i=0; i{ delay(0.2) PORTA = 0X00; delay(0.8) PORTA = 0XFF; } 占空比才是真正PWM应用的，其实就是开关的打开和关断的时间比值，这个比值在宏观上可以欺骗人眼，于是形成和电位器一样的作用。比如对一个电灯来说，你在1秒内，打开开关0.5秒，再关闭0.5秒，如此反复，那么电灯就会闪烁，但是如果是1毫秒内，0.5毫秒打开，0.5毫秒关闭，由于视觉暂留作用，也可能由于灯光的亮灭速度赶不上开关速度（还没全亮就又没电了），于是人眼不感觉电灯在闪烁，而是感觉灯的亮度少了一半。同理，如果是0.1毫秒开，0.9毫秒灭，感觉灯的亮度就只有1/10了。对于电机的原理也差不多，开关开时电机加速，关闭时电机减速，根据是加速时间多还是减速时间多，我们感觉总体的转速就是快了或慢了。当然，具体分析时还需考虑电机的电感作用，电感有滤波效果，但是用这个方式去理解也是成立的。 回到前面的频率问题，就如刚才说的，1秒内，0.5秒开，0.5秒灭，占空比是50%对吧？那么，1毫秒内，0.5毫秒开，0.5毫秒灭，占空比也是50%，对吧？如果是1秒呢，频率就是1HZ，如果是1毫秒，频率就是1KHZ，显然，同样是50%占空比，如果频率是1HZ，那电机肯定是跳着走的，灯光肯定闪得可以跳舞，不具有调速和调光的意义。 PWM 主要用途是通过对一个的电源开关控制可以得到输出电压大小和占空比成正比的电源，虽 然DAC 也可以输出与数字对应的电压，但这个电压驱动能力很弱，要想提供比较大的驱动能力实现 起来很难，但PWM 很简单，只要用三极管等做为开关控制元件向后面的大负载提供电源。对电源的 控制实际上也是对输出功率的控制，所以PWM 在马达转速、灯光亮暗这类控制上有着广泛的应用。 一周搞定系列 之 模电 第一章 基本元器件 二极管 二极管就是 把PN结封装起来 然后在P和N两端加个引线 特性： 单项导电性、伏安特性 属性： 1. 普通二极管导通后的电压值是(约)0.7V，0.5V时开始导通 2. 发光二极管导通后的电压值是(约)1~2V，电流范围是5~20mA，电流和电压不在此范围时，发光二极管不导通、不发光 3. 二极管反向不导通，但当反向电压足够大时也会导通，此时称为反向击穿 稳压二极管 具有稳压作用的二极管，用到了二极管的伏安特性。 在给二极管施加反向电压时，电流值处于 导通与击穿之间时，二极管电压处于稳定区域，此时二极管具有稳定（与其并联的）器件电压的功能。 要注意的是要选择合适二极管，给其施加的反向电压不能太小，太小将不能导通，太大将击穿二极管 稳压二极管的使用形式为：电阻和二极管的串联，二极管反向接入电压 整流二极管 用于把交流电编程脉动直流电 交流电是正弦波，将正弦波反向部分切除（即180到360的相位切除，因为二极管反向不导通），得到的即是脉动直流电，类似PWM方波，所以称为脉动 开关二极管 导通 和 截止 两种状态的切换时间比普通二极管快，使得其在电路中有开关作用，用于保护反向电流损坏所保护的器件 电容 电极板+中间介质封装而成。 电容具有旁路(支路)、去耦、滤波、和储能的作用 旁路 1）使输入电压均匀化，减少噪声对后级系统的影响 来自于电源的电压不保证是稳定的，或不保证一直是稳定的，不稳定的直流电压将影响数字电路系统的逻辑判定，这将导致致命的做错。 不稳定的直流电压的波形类似周期多变的交流电，而电容具有“通交流，隔直流\"的功能 ，在电源接入器件之间 并联旁路电容于GND，当有不稳定的直流电通过时将通过旁路电容过滤到GND 旁路电容应接到离器件较近的位置，而不是离电源较近的位置 2）进行储能，当信号变化过快时进行电压补偿 器件的高低电平快速切换可能导致输入电压供应不及时，此时旁路电容可将存储的电能及时释放补充给器件使用 去耦（退耦） 去耦电容和旁路电容类似，区别是旁路电容用于输入信号、去耦电容用于输出信号. 耦合-辞海 : 两个元素/量之间,其中一个量的变化,导致另一个元素/量的变化的一种关系 去耦连接器件输出信号，减少了输出信号不稳定信号对周围/下级器件的耦合作用 去耦电容一般相对较大，如10uF、旁路电容较小，如0.1uF 0.01uF 滤波 去耦/旁路电容的容值选择与滤波电路有关 这也与信号频率相关，因为大电容用于滤除低频噪声，而小电容用于滤除高频噪声 注意 铝解电容 连接分正负极，磁片、独石电容不分正负极 三极管 PNP 或 NPN结组成的晶体管 三极管具有三个极：b-basic基极 c-collector集电极 e-emit发射极 定义：称b-c之间的结为集电结、称b-e之间的结为发射结 三极管是利用“输入电流”控制“输出电流“的元件 即使用b基极的电流来控制e发射极的电流，可以把三极管类比一个水桶，c是储水区、b是开关区、e是流水区， b同样需要使用水流来控制开关的大小，b没有水流入时开关闸门关闭，C的水留不下来，e流不出来水，这种情况称为三极管的 “截止”状态 b给一定的水流，闸门开一定大小，此时c流下水，并且流下的水是b的倍数，此时称为三极管的“放大状态” b继续增大输入水流，闸门开到了最大，此时称为三极管的“饱和状态” 将水流依次比作电流，则有：Ie = Ib + Ic。Ic = βxIb ，即Ie = (1+β)xIb 定义：设b c e的电压为Ub Uc Ue Ub > Uc 称为集电结正偏，反之为集电结反偏 Ub > Ue 称为发射结正偏，反之为发射结反偏 要使三极管工作在截止状态，使Ue > Ub，即发射结反偏，或三极管电压为0 放大 ，使Uc > Ub, Ub > Ue, 即集电极反偏，发射极正偏 饱和 ，使Ub > Ue, Ub > Uc，即发射极和集电极都正偏 处于截止状态时，集电极与发射极之间相当于开路。 处于放大状态时，Ic由Ib控制 处于饱和状态时，集电极与发射极之间电压很小，相当于导线 工程上认为饱和时Uce=0.3V(硅）或0.1V(锗) 饱和状态时，Ic不再由Ib控制 附：三极管的特征频率 三极管工作也受（脉冲）频率的限制，但基本上可以满足大部分单片机，如9013为150MHz 场效应管 类似三极管，也是PN结构造的晶体管，三个电极为G-栅极、D-漏极、 S-源级 （类比三极管中的b、c、e） 不同于三极管的是场效应管是利用“输入电压”控制”输出电流“的元件 控制的电流为Id，Id受Uds和Ugs影响， 当Uds很小时,Id随Ugs的增大而增大、减小而减小，约成线性关系，称该区域为场效应管的可变电阻区 当Uds在X范围时，Id随Ugs变化，此时不受Uds影响，该居于称为场效应管的恒流区 当Uds小于1.5V时，Id=0，场效应管不导通，该区域为截止区 当Uds大于Y时，场效应管被击穿，Id突然增大，注意要对场效应管击穿做Id限制，否则管子将被烧坏，该区域称为击穿区 在横流区与击穿区之间的区域称为“过损耗区“，长期间在该区域工作会导致场效应管过热，为此要做好散射措施，如加散热片 VS 场效应管和三极管实现的功能类似，目的是控制输出电流，三极管的特点为： 1）电流控制器件，利用基极电流来控制晶体导电能力 2）输入阻抗不高 3）噪声大 4）反应速度快 场效应管的特点为： 1）电压控制器件，利用电压产生的电场来控制导电能力 2）输入阻抗极高（这意味着较小电流将产生较大电压，适合电压控制器件） 3）噪声小 4）反应速度慢 光耦 光耦实现了 “电-光-电”的转换，有发光二极管和光敏三极管组成 信号输入 发光二极管发光，光被光敏三极管接收，三极管决定电路通断 光耦又称光电耦合器（耦合见辞海），是小电流控制大电流或小电压控制大电压器件的一种安全方式，因为这是一种“无接触、无反弹”式电路控制 发声器件 喇叭、蜂鸣器等 喇叭为无极性器件，即没有正负之分 蜂鸣器分为有源和无源的，无源蜂鸣器内部没有震荡源，直接用直流不能驱动，需要2KHZ-5KHZ的方波才能驱动 ，有源蜂鸣器内部含有震荡源，直接输入（1.5V-15V）直流就可以发出声响 继电器 类似光耦，用低电压小电流去控制高电压大电流 继电器常用在开关速度不高的场合，否则使用光耦 光耦vs继电器 光耦 ：无触点、开关速度快、寿命长、负载能力小 继电器 ：有触点、开关速度慢、寿命短、负载能力大 所以，要求大负载能力且开关速度较慢的场合使用继电器，而小负载能力且开关速度较快的场合使用光耦 PS 电流与感觉 交流电 直流电 数码管 通过控制不同的LED灯来显示所需要的字符0~F 瞬态高压抑制器 TVS 二极管封装形式的高效保护器，放置瞬时高能量冲击，保护精密器件被各种浪涌脉冲破坏 1、加在信号和电源线上，能防止微处理器，人体 静电、交流浪涌或噪声，导致处理器的失灵。 2、能释放超过10000V，60A以上的脉冲，并能持 续10ms，而一般的TTL器件，遇到30ms的10V脉 冲时，便会导致损坏，所以利用TVS是既可以防止 器件损坏，也可以防止总线之间开关引起的干扰。 3、将TVS放置在信号线和地之间，能避免数据及 控制总线受到不必要噪声的影响。 一周搞定系列 之 模电 第二章 基本电路验证与分析 基本放大电路 基本放大电路的核心是三极管，电阻和电容辅助 三极管放大电路是小信号的放大，常用器件最大通过电流也只有几百毫安，所以输入信号不能太大 反馈 凡是将放大电路输出端的信号（电压、电流）的一部分或全部引回到输入端，与输入信号叠加，称为反馈 负反馈 - 引回的信号削弱了输入信号 正反馈 - 引回的信号增强了输入信号 电源电路 由整流桥、电容、二极管组成的电路 开关电源 集成运算放大器 具有很高放大倍数的多级 直接耦合的 运算放大电路 是发展最早、应用最广泛的 模拟集成电路 特点： 高增益、高可靠性、低成本、小尺寸 一周搞定系列 之 模电 第三章 仪表放大电路 积分运算电路 微分运算电路 有源滤波电路 采样保持电路 文氏桥振荡电路 功率放大器 功率放大电路是一种以输出较大功率为目的的放大电路 特点： 输出信号电压大 输出信号电流大 放大电路的输出电阻与负载匹配 电压放大器与功率放大器的区别 电压 - 不失真的提高输入信号的幅度，通常工作在小信号状态 功率 - 不失真或轻度失真的条件下提高输出功率，通常工作在大信号状态 一周搞定系列 之 模电 第四章 实际电路应用 多路稳压电源 数控恒流源 "},"pages/Digital.html":{"url":"pages/Digital.html","title":"Digital Elec","keywords":"","body":"芯片及相关术语 总线驱动器： 一．解释 MCU具有一定的负载能力，如果外设过多或所需驱动电流/电压导致MCU负载能力不够，就需要驱动器来提升驱动能力。总线驱动器具有很大的扇出系数，可将输入逻辑信号进行功率提升送到输出端。总线驱动器一方面可实现对总线的驱动，另一方面也可实现对总线的隔离，隔离的能力还是来自于三态门。 功率提升的本质是电流的提升。 二．应用 在屏幕显示及大部分消费类电子产品中常需要驱动器。 译码器： 译码是编码的反过程，是将二进制代码翻译成特定的输出信号。 分类： 二进制译码器 又称n->2ⁿ线译码器，即将n种二进制输入组合翻译成2ⁿ种高低电平信号。 74HC138是二进制译码器中的一种 二 - 十进制译码器 将二进制代码翻译成十进制数。这种译码器有4个输入端10个输出端。 显示译码器 将二进制代码翻译成显示器可显示的数字或文字。 时钟 时钟 = 协调 协调系统部件工作节奏 各干各的是不行的 必须有统一的节奏（注意是统一而不是同一，如：部件A的工作节奏[频率]是1秒中100次，部件B的节奏为2倍的A ，这是统一的节奏，也可以说是所有部件/器件的工作频率是可以相互逻辑推算的） 它的角色像人体的心脏，像乐队的指挥家 三态门 概念 TTL电路只有高电平（1）和低电平（0）两种状态，而三态门（TSL）具有高电平、低电平和高阻态（Z）三种状态，故称三态。三态门的核心就是高阻态的应用，在半导体电路结构中不可能使用闸门开关来闭合电路（设计上和速度响应上都是不现实的），而高阻态（电阻无穷大）可以被认为是开路状态，起到了半导体电路的开关作用 - 半导体电路控制开关。 符号 应用 1. 总线的分时复用 三态门主要用于TTL电路与总线间的接口电路，如果一个设备要挂到总线上，则必须要经过三态门，因为总线上一个时刻只能与一个设备通信，此时其它设备要呈高阻态 2. 数据的双向传输 通过两个三态门的设计可实现一根线路的双线传输 一周搞定系列 之 数电 第一章 逻辑门 逻辑门的电路分类 按功能 与 或 非 异或 与非 或非 与或非 跟数学上的与或非一样，如，与：一假则假，在C语言中就是 && 或：一真则真，在C语言中就是 || 非：反之 ，在C语言中就是 ~ 异或：同假亦真 只不过表达式不太一样：如，与：Y = AB 或：Y = A+B 非：Y = 非A 异或：Y = A 圈加 B 按电路结构 TTL集成门电路 输入端和输出端都用三极管的逻辑门电路 COMS集成门电路 用互补对称MOS管构成的逻辑门电路 按功能特点 普通门，推拉式输出 输出 开路门 三态门 COMS 传输门 高电平和低电平 高低电平是在某一范围内的电位值，非固定值，也非固定范围 正逻辑： 高电平 3.5~5V 低电平 0~0.3V 负逻辑： 高电平 0~0.3V 低电平 3.5~5V OC门 - Open collector gate (三极管的)集电极开路的门电路 1. 自己加上上拉电阻和电源可以增加驱动能力 2. 实现“线与”逻辑 OD门 - 漏极开路的门电路，功能类似OC 三态门 具有三种状态的门电路，分别为高电平、低电平、高阻态 COMS传输门 COMS门电路 VS TTL门电路 1. 功耗极低 2. 抗干扰能力强 3。电源电压范围宽 4. 输出信号摆动幅度大 5. 输入阻抗高 6. 扇出系数大（带负载能力强） 7. TTL门比COMS门电平反转速度快一些 一周搞定系列 之 数电 第二章 组合逻辑电路 由逻辑门电路组合而成的电路 一周搞定系列 之 数电 第三章 编码器和译码器 二进制代码与某种编码的相互转换 编码器的类型 1. 二进制编码器 用N位二进制对2^n个输入信号进行编码的电路 2. 2-10进纸编码器 将0~9十个十进制数转换成二进制的译码电路 3. 优先编码器 一周搞定系列 之 数电 第四章 触发器 数字电路分为 组合逻辑电路 和 时序逻辑电路 两类 组合逻辑电路的基本单位是 门电路 时序逻辑电路的基本单位是 触发器 门电路在某一时刻的输出信号完全取决于该时刻的输入信号，没有记忆功能 触发器具有记忆功能，能够在无输入信号的时候，保持上一次输入信号的状态 触发器的现态和次态 现态Qn ---- 触发器接收输入信号之前的状态 现态Qn+1 ---- 触发器接收输入信号之后的状态 分类 从电路结构不同分：基本触发器、同步触发器、边沿触发器 基本触发器： 输入信号直接加到输入端，是触发器的基本电路结构，是构成其它触发器的基础 同步触发器： 输入信号经过控制门输入，控制门受时钟信号CP控制 边沿触发器： 只在时钟信号CP的上升下降沿时刻输入信号才能被接收 从逻辑功能不同分：RS触发器、JK触发器、 D触发器、T触发器、T‘触发器 一周搞定系列 之 数电 第五章 计数器 用来统计输入计数脉冲个数的电路 计数器由触发器构成，因为触发器具有记忆功能，1个触发器单元能存储一位二进制数 应用：计数、定时、分频 一周搞定系列 之 数电 第六章 电路设计 (无程序控制的，纯电路设计，如简易秒表、抢答器等等） "}}