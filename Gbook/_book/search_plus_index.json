{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"pages/Git.html":{"url":"pages/Git.html","title":"Git","keywords":"","body":" 1.1 关于版本控制 版本控制，是记录文件内容变化，并提供增、删、改、查和回溯等功能的系统 版本控制系统（VCS） 分为：本地VCS、集中VSC、分布式VCS 最简单的版本控制，就是一个版本，一个目录，但这样很蠢，容易出很多问题， 本地VCS（如RCS），利用硬盘上保存“补丁集”的办法记录文件的变化，通过所有补丁可以计算出各个版本的内容 本地VCS只能供自己使用（或只能供本台机器使用，或拥有一个磁盘的机器使用），如果想要多个开发者协同工作，那就需要一个集中式的VCS（如CVS、Subversion、Perforce等），集中式VCS使用单一的一个服务器，保存所有文件的修订版本，所有协作者通过客户端连接到服务器。 集中式VCS最大的缺点就是服务器的单点故障，在恢复之前不能进行协作开发工作，如果服务器磁盘故障，那么整个项目的变更历史都将消失，各个客户端只保存了单独的快照 于是分布式VCS出现了（如Git、Mercurial、Bazaar、Darcs），它不只提取最新版本的快照，而是克隆代码仓，这样服务器有问题，就可以使用任意一个客户端恢复。 分布式VCS还有许多新的优势 1.2Git简史 1991年~2002年，在Linux内核开发过程中，绝大多数的内核维护工作都花在了提交补丁和保存归档的繁琐事物上，到2002年项目组开始使用BitKeeper的VCS来维护。 到了2005年，开发BitKeeper的公司同Linux内核开源社区合作关系结束，自此开始收费，这迫使Linux torvalds 基于BitKeeper的使用教训，开发出了自己的VCS，并对其定制了若干目标： ①速度 ②简单的设计 ③对非线性开发模式的强力支持（允许成千上万个并行开发分支） ④完全分布式 ⑤有能力管理类似Linux内核一样的超大规模项目（速度和数据量） 子2005年以来，git日渐成熟完善，并应用到无数的项目当中。 1.3GIT基础 git对待数据像“快照流”， 注意：快照技术，不同于备份。理解了快照技术，就理解了GIT的基本思想。 次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件 git不是一个简单的VCS，更像是一个小型的文件管理系统 相比其他VCS，git几乎所有的操作都在本地完成，因为本地拥有项目的完整历史，因此速度极其快 没有网络时可以愉快的编写项目，直到有网络再上传，这样的操作在其它VCS是不存在的 git存储和提取版本使用校验和算法（SHA-1），以保证完整性 1.4命令行 1.5安装 1.6配置 初次运行git前的配置：git config，操作gitconfig文件，来设置控制git外观和行为的配置 gitconfig存在/ect/gitconfig中、对应git config --system 选项，表示本机全局 ~/.gitconfig 或~/.config/git/config，对应git config --global，表示本机当前用户 .git/config ，表示本机该仓库 每一个级别可以覆盖上一个级别的配置 用户信息配置： git config [--system/--global/无] user.name “xxx” git config [--system/--global/无] user.email “xxxx” git config --list 列出所有git能找到的配置s git config 列出某一个配置，如git config user.name 2.1 获取GIT仓库 1.对现有项目管理，在项目目录使用git init 2.从服务器克隆：git clone 。如git clone https://github.com/libgit2/libgit2，则本地出现libgit2目录，如果想重新指定仓库名：git clone [name]，如git clone https://github.com/libgit2/libgti2 mylib git支持http https和SSH协议 2.2 命令和几个区域 git status git add 文件，以开始跟踪这个文件 跟踪区域分为：未跟踪区、跟踪区、不跟踪区 未跟踪区到跟踪区，使用git add +文件，反之使用git checkout +文件 不跟踪的，添加到.gitignore文件中 git add是一个多功能命令，1是可以添加跟踪文件，2是如果修改了已跟踪的文件，那么需要再次add一下，来暂存更新，如果不运行这一次add，那么下一步进行提交时，就没有这部分修改更新，换句话说，add的作用是为了提交做准备。 文件 .gitignore 的格式规范如下： 所有空行或者以 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 git diff 查看尚未暂存的改动， git diff --cache git difftool 可以调用插件 以图形化方式对比差异 git commit 存储快照！核心的一步，这就在git中增加了一个版本 git commit -m指定信息 如果直接使用git commit，将调用git指定的编辑器，来指定提交信息 git config ... core.editor 命令可以指定编辑器 git commit -a 可以跳过暂存，即不必add之后再commit git rm可以从已跟踪文件清单中移除文件，并连带从工作目录删除该文件，如果只想从清单中移除，而不想删除文件，使用git rm --cache。 如果删除之前，该文件修改过，还没有放入暂存区，则需要使用git rm -f 来删除，这是安全机制，避免没有形成快照的文件被删除，因为这样的数据不能被恢复。 git mv == mv A B, git rm A, git add B git log 查看提交历史，使用-p参数可以查看每次提交的内容差异，使用-n指定数字可以查看最近n次的内容，--stat显示简略信息，使用--prettye=子选项，可以显示不同格式信息，子选项有oneline、short、full、fuller、format等等。使用--graph可以显示使用ASCII字符模拟的图形 还有其他更多选项 撤销操作： git commit --amend 可以修改最近一次的提交信息 git reset HEAD +文件，是git add的逆操作 对git add之后的文件做了修改，要丢弃这部分修改使用git checkout -- +文件，该命令不可逆 1.6.1 一. 简介 Git（Global Information Tracker，全局信息追踪器）是一款免费、开源的分布式-版本控制系统（VCS），由Linus Torvalds创建（2005.04上线），最初用于管理Linux内核开发。因其性能优异，现已成为主流的分布式VCS。 Git官网：https://git-scm.com/；可在线安装：“#yum install git”；也可通过下载源码编译安装，源码下载地址：https://www.kernel.org/pub/software/scm/git/，其编译安装方式同通用步骤：“#configure && make && make install”；注：Git源码依赖Python、libcurl、perl、zlib、ssh等众多库。 https://git-scm.com/book 二.入门 a)创建版本库 新建一个空目录，或在你的工程顶级目录运行“#git init”，则创建了一个Git版本库，库名为隐藏目录“.git”，以下称“.git”目录为版本库。 b)添加文件 Git只对版本库内的文件负责，而不监测除版本库以外的任何目录。可以通过“#git add xxx”命令将项目文件添加到版本库，xxx可以是当前目录或其它目录下的一个或若干个文件。 使用git status可以查看当前版本库状态 git rm --cached ...\" 以取消暂存 add命令是暂存操作，Git将xxx文件暂存，暂存的目的是为避免项目文件的频发变化，可以多次添加，一次性提交，可以理解为add命令是将项目文件添加到缓冲区。 使用“git commit -m \"t1\" --author=\"zi 303683086@qq.com\"”命令，可将缓冲区的文件提交到版本库，-m和--author必须使用，-m是提交的备注信息，--author指定作者，格式必须为“Name ”，如果提示地址有问题，则可以通过配置文件永久指定地址或通过全局参数“--global”：“vim xxx/.git/config”修改name和email。或“git config --global user.name=’xxx@yyy.com’ && git config --global user.name ‘NAME’”也可以使用全局变量：“GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL”，上述两种方式是全局设置，可以通过不指定--global来本地生效。 -m 选项也可以通过环境变量配置，使每次提交时自动打开一个编辑器编写备注：“export GIT_EDITOR=vim”，这样只需运行命令“git commit”就会打开vim编辑器，按提示编写备注，保存退出即提交成功。 此时运行“git status”显示工作区干净的提示。 对xxx文件简单的修改，此时不必再运行add命令，直接可以commit提交，因为该文件已经提交到版本库，版本库已经对该文件建立了索引，但这次提交需要指定文件名：“git commit xxx” 两次提交之后，版本库中已经有两个版本的xxx了。 git log 可查看提交历史，从最早陈列一个简易列表，每次提交历史都包含一个“commit !@#$2341”，这是由Git产生的提交码，唯一指定提交历史，使用：“git show !@#$2341”，可显示当次提交的详细信息。如果不指定提交码则显示最近一次的提交历史。 使用git diff xxx yyy，（xxx yyy为提交码）可对比两次提交历史。 一种说法：注：git版本库中t版本库中存储每一提交文件的修改，而不存储文件本身（第一次提交存储全部内容）。git记录了每一次的修改内容，给每一次的修改记录索引，通过索引可以寻找和回滚历史版本。 有了Git，就不需要其它命令行工具来管理项目，比如要从项目中删除一个文件，则执行：“#git rm xxx”（前提是该文件已经提交到版本库），这样既从项目目录删除了xxx文件，又从版本库中删除了xxx文件。 删除之后同样要进行提交“#git commit”这样才能最终实现变更。 “git mv xxx yyy”命令可实现版本库文件的重命名，然后记得进行提交操作。 通过git clone 命令可以克隆任一版本库 git配置文件：git配置文件已.ini结尾，它们记录了Git命令使用的各种选项和设置，有些设置是个人偏好，有些设置是版本库正常运作的必须，三个位置存有git配置文件：“.git/config ~/.gitconfig /etc/gitconfig”，优先级按先后生效。也可以通过git config 或 git config --global临时生效。使用git config -l 列出所有配置文件的信息。可以使用git config --unset 或 git config --unset --global 来移除设置。 c) 三. 文件： 1.git 配置文件 分别在/etc/gitconfig ~/.gitconfig .git/config 对应命令：git config --system , git config --global, git config 2.忽略检测文件 touch .gitignore, 支持glob匹配模式，注释用# 3.重命名git mv x y= mv x y, git rm x, git add y mkdir src; git mv x src;git commit(新建文件夹并移动) 4.日志git log、git log -p、git log -p -2、git log --stat git log --pretty=oline/short/full/fuller/format/ git log --pretty=oline/format --graph git log + git show (+SHA-1) 5.git 中任何提交(commit)的都是可以恢复的 当多人在一个文件中协同作业时，提交自己的代码 到远程仓可能失败，是否失败取决于你是否是团队 第一次提交这次作业源码的人，如果不是，就要pull 一次，以更新团队代码到自己的源码中，然后在push checkout 用于从（本地）库 中恢复之前提交过的某一节 点文件（包含删除的文件） git remote show origin git remote rename xx git remote rm git push origin master account:xyZaki password:umbrellxxxx 【设置密码，免推送输入：echo https://xyZaki:umbrellaxxx@github.com > ~/.git-credentials；vim ~/.gitconfig , 输入[credential] helper = store】 git reset 重置分支到某一次commit的指针 --soft 只重置，不做指针破坏 --hard 删除重置后，从重置点到最芯一次commit的指针, git checkout -- + 文件 恢复文件（加--是为了避免分支名与文件名冲突） git checkout + 分支 切换分支 git branch newb 创建分支 git checkout newb 切换分支 git checkout -b newb 等于上述2条命令 git merge SOMEBRANCH 合并其它分支到当前分支，以更新当前文件 补丁操作： 创建补丁：git format-patch -N （N表示创建几个PATCH（从最后一次提交计算），结果是每次提交的补丁） 补丁用于给它人使用，以更新数据（推测可能不具备克隆的条件时使用） 应用补丁：git am（应用补丁并提交） /git apply（应用补丁不自动提交） 分支：git的分支，仅在本地分支、自己使用，是没有意义的。分支应该用于开发协作，分支应该起始于远程仓中（或由本地管理者本地建立后推送至远程仓） --- 分支与切换、存储问题实例：PSCC31项目需新增1.32版本，但又需要保留之前的1.31版本，所以新增分支V1.32 git branch V1.32 //新建分支V1.32 git checkout V1.32 //切换到新的分支 然后修改了一些（已经存在的）文件 修改之后，此时想回到master分支修改一些东西， git checkout master 但发现在V1.32里面修改的内容，也在master分支上同步了 原因是，在新的分支修改完内容之后，需要git add . & git commit -m “xxx” 再切换，内容才不同步， 但是，我现在又不想对新的分支进行提交， 那么就需要暂存起来：git stash 再切换到master，内容就不会同步了， 在master操作完成之后，要切回V1.32，把暂存的内容调出来继续编写 git checkout V1.32 git stash list //查看暂存列表，因为可能暂存多次 //类似这样：statsh{0}: WIP on V1.32:dca0dd7 ..... git stash applay stats{0}//这样就调出了指定的暂存内容 刚刚进行stash的时候，没有起名字，如果stash了多次，怎么才能调用出自己想要的呢？ 那就是要起名字：git stash save xxxx 使用 git stash pop 可以调用最近一次stash的内容 使用git stash clear 清空所有stash 使用 git stash show 可以查看stash的修改 ==================================================================== "},"pages/C++.html":{"url":"pages/C++.html","title":"C++","keywords":"","body":"Jim C++ Catalog 一. 简介     C++起源于贝尔实验室，从C派生、与C兼容、编译时绑定。C++融合了POP、OOP和泛型编程（模板）等编程方式，使用 类 和 对象 来描述数据，强调数据的表达方式，具有封装、继承、多态、异常处理等特性。    附：C++之父Bjarne Stroustrup的个人主页。     二. 抽象     “抽象指从具体事物中被抽取出来的相对独立的各个方面、属性、关系等。” -- 《辞海》。C++的抽象是通过“类”来表示一类实物的共有属性，是泛型编程的基本思想。    类的本质是操作受限的结构变体，对象是结构体变量，关键词class和struct在C++中等效。类的成员分为属性（变量/数据等）和方法（函数/行为/动作/功能等）。     语法：class/struct CLASS_NAME{...attribute list AND function list...};     传统结构体的使用方式是类的使用方式的子集，类还具有方法成员和权限控制能力。 三. 封装     C++类的成员具有访问限制：Private（私有，默认）、Protected（保护）、Public（公有）。 封装方式访问限制 Public无 Protected类、友元函数、派生类 Private类、友元函数     一般将数据成员设计为私有、方法成员设计为公有，仅对派生类开放的成员设计为保护类型。类的对象通过公有或保护方法来操作私有数据。C++将结构体扩展成类，具备类的所有特性，但默认访问限制为公有。     语法：class/struct CLASS_NAME{... pulic:... protected:... private:...};     C++类的特殊方法成员可以在对象创建、复制和销毁时被系统自动调用：构造函数、拷贝构造函数和析构函数。     1. 构造函数与创建对象     构造函数是类中与类同名的公有方法成员，可缺省、可重载、无返回值，在对象被创建（于堆或栈）时由系统自动调用，常用于初始化属性成员和自定义初始动作。     语法：class/struct CLASS_NAME{... pulic: CLASS_NAME(Param list){...};};     → 创建对象的方法：     + 栈中：class/struct CLASS_NAME            OBJ ;    + 堆中：class/struct CLASS_NAME *Pobj = new OBJ ;     默认构造函数形参为空，创建对象时未传参则调用默认构造函数。     2. 拷贝构造与复制对象     拷贝构造函数是构造函数的特例，本质是构造函数的重载，含一个类引用形参，在对象被复制时由系统自动调用，用于处理因对象复制可能导致的内存泄露、重叠等问题。    原则上凡是包含堆和指针成员的类都应该提供拷贝构造函数并合理重载“=”运算符。对象复制发生于三种情形：向函数形参传递对象值、从函数返回对象值、对象赋值。     语法：class/struct CLASS_NAME{... pulic: CLASS_NAME(CLASS_NAME &){...};};     → 浅拷贝与深拷贝：    浅拷贝又称位拷贝，同普通变量赋值，即将A的内存空间数据按位复制到B。缺省的拷贝构造函数和未重载的“=”运算符都为浅拷贝。    当类中存在指针时，如使用浅拷贝，对象A和B的指针成员将指向同一内存空间而导致内存重叠，如果指针指向堆，则在对象销毁时该空间会被释放两次，深拷贝需要设计拷贝构造函数，使对象复制发生时完全拷贝内存镜像。     3. 析构函数与销毁对象     析构函数是类中与类同名的、带有“~”前缀的公有方法成员，可缺省、不可重载、无参、无返回值，可手动调用或在对象被销毁（于堆或栈）时由系统自动调用，常用于释放空间和自定义结束动作。     语法：class/struct CLASS_NAME{... pulic: ~CLASS_NAME(){...};};     → 销毁对象的方法：     + 栈中：栈中的对象在其所在作用域结束时自动销毁    + 堆中：delete Pobj;     4. 友元函数和友元类     友元是类外的、可以访问该类中所有成员的函数或类，称友元函数和友元类，使用friend关键词声明。友元关系是单向的，不具有传递性且不能被继承。友元破坏了类的封装性又适当的打破了封装的局限性，使编程更加灵活。     语法：class/struct CLASS_NAME{... friend R_TYPE FUN(...); ...friend class CLASS_NAME;}; 四. 继承     继承是C++代码重用和功能扩展的重要机制子类（派生类）通过继承父类（超类、基类）来重用、实现和扩展父类的功能，并可多重继承，是自下而上的过程。     语法：class/struct CLASS_NAME : WAY CLASS_B, WAY CLASS_C, ...{...};     WAY表示Public、Protected和Private继承方式，用于限制子类对父类成员的访问权限。 继承方式 父类成员 publicprotectedprivate publicpublicprotected不可见 Protectedprotectedprotected不可见 Privateprivateprivate不可见     父类私有成员总是对子类不可见的，父类公有成员限制随继承方式改变，父类保护成员仅在私有继承时改变访问限制。在内存分配上，子类深拷贝了父类Public和Protected成员。     构造、拷贝构造和析构函数不能被继承，子类构造对象时先调用父类（默认）构造函数，并可指定形参以调用父类重载的构造函数。子类拷贝对象时先调用父类拷贝构造函数、析构对象时反之。     1. 多继承与二义性     一个子类可继承于多个父类（一般多继承），当不同的父类中拥有同名（和同参）成员，且子类可访问时，则可能产生二义性。消除一般多继承二义性的方法是子类重载或重写父类二义性成员或调用父类二义性成员时指明作用域“::”。     2. 虚继承与二义性     在一般多继承情形下，如果不同的父类继承于同一个超类（菱形多继承）且子类可访问时，则可能产生二义性。消除菱形多继承二义性也可通过消除一般多继承二义性的方法，或使用虚继承，即超类在派生父类时使用关键字“virtual”。     语法：class/struct CLASS_PARENT : virtual WAY CLASS_Base, ...{...}; 五. 多态     C++继承衍生了多态特性，继承于同一父类的不同子类通过重写父类的（纯）虚函数来实现不同功能的方式称为多态，是自下而上的过程。     1. 静态联编     函数重载（和操作符重载）是实现静态联编的主要方式。在编译阶段，编译器会根据重载函数参数类型和个数的不同而生成不同的符号列表，从而形成可根据不同参数类型和个数来调用的同名函数。     → 函数重载     在同一个作用域中声明的具有相同函数名而不同参数个数和（或）类型的函数，称为函数重载（与返回值无关）。     附：默认形参与二义性    C++允许在定义函数时指定形参默认值，顺序必须从右向左，调用函数时可以从右向左省略形参以使用默认形参。如果带有默认形参的函数又被重载，则调用时必须指定足够个数的参数以避免二义性。     语法：R_TYPE FUN_NAME (Param1, Param2=N, Param3=M, ...){...};     → 函数重写（覆盖）     派生类会覆盖基类中与基类同名、同参函数，如需调用基类函数，则需使用作用域“::”。     → 运算符重载     重载的运算符表现为由关键字operator指定的、以运算符为函数名的函数，重载的运算符必须是有效的C++运算符（附录D），参数个数必须与运算符操作数相等，且至少一个属于复合类型（class/struct/enum）。     运算符将表达式中的第一个操作数作为第一个形参，第二个操作数作为第二个形参。操作符重载可以定义在类的内外，当在类中定义时，第一个形参省略，默认为所在类的类类型。运算符“=”必须在类中定义。     语法：R_TYPE operator 操作符([class/struct/enum] NAME [OPT *指针, &引用, ...], ...){...};     C++只检测形参的合法性，不检测函数内部实现机制，也不要求返回值，但重载的功能应该符合原运算符的语法规则、属性和优先级。合理的返回值设计也方便参与连续的链式运算。     2. 动态联编     动态联编是C++多态的主要实现方式，它通过虚函数与虚类、纯虚函数与抽象类在运行而非编译时确定接口的实现。     → 虚函数与虚基类     将基类函数声明为虚函数，通过派生类的重写即可实现运行时多态，包含虚函数的类称为虚基类。声明成虚函数的意义在于对内存模型的建立（虚表），从而可用基类的指针通过赋值不同的派生类对象地址来实现不同的功能。     语法：class/struct CLASS_NAME{public/protected: virtual R_TYPE FUN_NAME(...){...}; ...};     构造、拷贝构造与析构函数是否声明为虚函数与虚函数表技术有关，参看附录E。     → 纯虚函数与抽象类     纯虚函数只有声明没有实现，也不能实例化对象，所有的实现都交给派生类，包含纯虚函数的类称为抽象类。抽象类的派生类必须实现抽象类中所有的纯虚函数，抽象类表现为一个行为接口。     语法：class/struct CLASS_NAME{public/protected: virtual R_TYPE FUN_NAME(...)=0; ...}; 六. 模板     模板是C++泛型编程的基础，可以独立于任何特定变量类型的方式编写代码，包含函数模板和类模板。在设计函数和类时可以在任何关于变量类型的地方设置模板（T），在使用时可以指定任意类型变量以实现泛型编程。     语法：template class CLASS_NAME{}; / ... FUN_NAME(...){}    备注：模板函数的形参必须包含所定义的所有模板，不要求返回值。模板在类中可自由定义     STL（Standard template library）     标准模板库由HP实验室研发，现已成为C++标准。STL包含大量数据结构和算法的类模板，并将数据结构和算法分离。     STL包含三种类型代码：容器（Containers）、算法（Algorithms）和迭代器（iterators）；容器是抽象数据类型的模板实现（模板类），即数据结构，如动态数组、列表、队栈、图等。算法用于操作容器（模板函数），如增、删、改、查等。迭代器（又称游标）用于遍历容器，如递增、递减、定位等。     容器类中的方法是针对特定的数据结构而设计的，更多使用的是非成员方法（即算法）来操作容器。特别的，容器类中存在与算法同名的方法，原因是相比通用算法其执行更有效率。     模板使得算法独立于特定的数据类型，迭代器使得算法独立于使用的容器类型。 七. 异常     C++异常是处理程序错误的重要机制，不同于传统C的返回值判定、信号、断言、错误编号、跳转等处理方式，异常处理可获得更详细和精准的信息并将问题检测和问题处理分离，通过关键字$\\color{#FF0000}{try}$检查异常、throw抛出异常、catch捕获异常，如果抛出异常后未进行捕获，则程序将被终止。     语法：CODEBLOCK{throw [expression]}; try{CODEBLOCK}catch(exception param list){...}...catch(...){...}     try-catch语句可以（在try代码块中）嵌套，catch列表及外层catch列表中至少要有一个形参匹配所抛出的异常量类型，否则发生异常时程序将被终止。可在列表最后设置catch(...)以匹配任何异常类型。     将嵌套内层捕获到的异常再抛出（到嵌套外层）的方法是再次利用throw语句，但表达式为空。 一般当嵌套内层无法处理某些异常时会利用该方法。     备注：throw语句将终止执行后续指令、expression可以是任何表达式语句      在函数声明和定义时可使用关键词noexcept修饰以说明该函数不会抛出异常，如果该函数仍然抛出异常，则程序将被终止。这种机制可有效阻止异常的扩散。     语法：R_TYPE FUN_NAME(...) noexcept {...}     → 标准异常     C++内置多个标准异常类，所有异常类都包含what()方法用以描述异常信息。其中exception是所有标准异常类的父类（详见附录F），可以通过继承标准异常来扩展异常。 附录 D 不可重载运算符 运算符描述 .成员访问运算符 .*, ->*成员指针访问运算符 ::域运算符 sizeof- ?:- #预处理符号 附录 E 虚函数表与指针     编译器会为虚基类（和抽象类，下同）中的虚函数建立虚函数表（V-Table），虚函数表是一个数组，数组元素是按虚函数声明顺序排列的、指向各虚函数的指针（_vptr）。     虚基类及其派生类都使用一个指针空间（前4Byte或8Byte）来存放虚函数表指针，虚基类每实例化一个对象，就为该对象添加一个虚函数表指针，对于多重继承的类就添加多个虚函数表指针。一个类的所有对象都共享同一个虚函数表。          派生类继承虚基类的同时继承其虚函数表，派生类的虚函数指针列表存放于虚基类的虚函数指针列表之后，当派生类重写某个虚函数时，就将虚函数表中虚基类的虚函数地址覆盖掉。          → 虚析构函数与内存泄漏     当虚基类的指针指向派生类的对象实现多态时，销毁基类指针时系统只能调用基类析构函数而不会调用派生类的析构函数，从而可能产生内存泄漏。通过将基类析构函数声明为虚函数，在销毁基类指针时还会调用派生类的析构函数。     → 虚基类成本分析     TBD 一.C++抽象 (1)this指针 对象的地址向成员函数的传递是编译器自动完成的，方式是作为成员函数的第一个隐含形参，这个形参就是this指针。this指针属于类，指向被实例化的对象。 通过*this/this可返回对象/对象地址，常用于避免成员变量与形参同名产生的歧义。 (2)静态成员 类中的静态成员是受限于类作用域的static类型的变量和函数，不属于任何对象，不占用对象空间，也没有this指针，静态函数只能访问静态变量。 访问静态成员的方法是直接使用类作用域“::”，类中一切不需要实例化就可以确定行为方式的函数都应该设计为静态的。 类的静态变量必须在类外、main函数之前初始化，且需指定类并省略static关键字。 -临时匿名对象 class a{ a(){}; a(int i){...} }; a(); //临时匿名对象，调用后马上又被析构 a(1); //临时匿名对象，调用后马上又被析构 a(aa) //相当于 class a aa; class a aa; aa = a(); //临时匿名对象，但对象又被接管，这不会调用拷贝构造，并且临时构造对象不会马上被析构 --组合：一个类包含另一个类的对象（以其它类的对象为成员） C++ 11 关键词auto新解： 原auto被使用频率很小，所以C++11将auto赋予新的含义，即具有自动推导功能，这就导致使用auto的同时必须被初始化，也就导致auto不能做形参： auto a = 1; int b = 10; auto a = b; vector c; auto a = c.begin(); 如此这般，auto变量会因赋值类型而自动推导。 附录A. C++命名空间与作用域 namespace SPC_NAME{...}; using namespace SPC_NAME; using SPC_NAME; C语言定义了三类作用域：文件、函数和复合语句，C++增加了类作用域“::”和命名空间作用域，命名空间将同名全局作用域的函数和变量分离，使程序扩展更加便捷。命名空间可以嵌套，使用命名空间通过using关键字或直接限定前缀SPC_NAME::X。 C++标准命名空间为“std”，标准库无“.h”或“.hpp”结尾的头文件均包含于标准命名空间中。参考命名空间实例：c++_link\\namespace.cpp 附录C. C++引用 var_type &quote = var；var_type &fun(...var_type &); 引用是变量的别名，类似Unix系统下的软链接，不占存储空间，向函数传参和作为返回值时相比传值、传址（指针）具有较高的效率和安全性。引用的声明和定义必须同时完成，一旦定义就不能重复绑定。 附录D. C++向C兼容 extern “C”{C function declare list}; 在C++出现之前已有大量的C源码，为向下兼容，C++允许与C代码混合编程，方法是使用关键字extern“C”限制于C函数声明列表。 在编写C程序时，为了方便向上兼容可对C函数声明列表设定宏开关：c++ link\\extern C.h。 附录H. C++资源 项目 地址/名称 描述 网址 C++ FAQ C++常见问题 网址 Free Country 免费的C++库，涵盖压缩、存档、游戏、GUI等编程 网址 C and C++ Users Group 免费C++库，涵盖AI、动画、加密、数据库等编程 书籍 Essential C++ - 书籍 C++ Primer Plus - 附录I. C++标准异常 std::exception 所有标准 C++ 异常的父类 std::bad_alloc 通过 new 抛出 std::bad_cast 通过 dynamic_cast 抛出 std::bad_exception 处理 C++ 程序中无法预期的异常时非常有用 std::bad_typeid 通过 typeid 抛出 std::logic_error 理论上可以通过读取代码来检测到的异常 std::domain_error 当使用了一个无效的数学域时，会抛出该异常 std::invalid_argument 当使用了无效的参数时，会抛出该异常 std::length_error 当创建了太长的 std::string 时，会抛出该异常 std::out_of_range 通过std::vector 、 std::bitset<>::operator等抛出 std::runtime_error 理论上不可以通过读取代码来检测到的异常 std::overflow_error 当发生数学上溢时，会抛出该异常。 std::range_error 当尝试存储超出范围的值时，会抛出该异常。 std::underflow_error 当发生数学下溢时，会抛出该异常 附录I. C++标准与头文件 ANSI 与ISO 于1998年通过C++98标准， 03年更新标准为C++03，该标准只修正了C++98标准的错误，因此用C++98表示 C++98/C++03。2011年通过了C++11标准，该标准较C++98增加了众多特性，同时还提供了C++标准类库。 C++标准规定标准类库使用无后缀的头文件以区别传统C格式和自定的头文件，C++保留了C的头文件并增加了从C转换后的无后缀头文件（eg： => ），所有无后缀的头文件都支持命名空间。 附录J. C++ new与delete C++使用new和delete开辟和销毁堆空间，与C中的malloc和free的使用方式类似，本质上是对malloc和free的封装。 noexcept可有效阻止异常的传播与扩散 include "},"pages/Communication.html":{"url":"pages/Communication.html","title":"Serial Communication","keywords":"","body":"CATALOG 一. 串行通信基础 1 异步串行通信 1 同步串行通信 1 主从串行通信 2 二. 串行通信线路 2 单工通信 2 半双工通信 2 全双工通信 3 三. 串行通信协议 3 UART 3 (1) UART组成 4 (2) RS232 4 (3) RS422 5 (4) RS485 6 SPI 6 IIC 7 //TBD 7 附录A：奇偶校验（Parity check） 8 附录B：波特率与比特率 9 附录C：握手（流控） 10 附录D：RS232接口标准 11 附录E：UART转RS232（DB9） 12 附录F：UART转RS422 13 附录G：共模抑制 14 一.串行通信基础 计算机的数据传输有并行和串行两种方式，并行传输的特点是每个数据位都使用独立的数据线同步传输，传输速度快、效率高，缺点是长距离传输成本高且存在电磁干扰，因此常用于短距离的计算机内部数据传输。 串行数据传输的特点是所有数据位都通过一根数据线传输，速度相对较慢，但传输距离远（几十米到上千米）、成本低，是网络通信、处理器与外设通信的主要方式。串行通信按时序分为同步和异步两种方式，按控制规则分为一主多从和多主多从两种方式。 1.异步串行通信 异步串行通信是以数据帧为单位的间歇传输形式，通过插入标志位来实现数据收发双方的协调。数据帧中包含起始位、数据位、奇偶校验位和停止位。起始位（1位）用于标志传输开始、数据位为5~9位、奇偶校验位用于数据有效性检查（见附录A）、停止位（1/1.5/2位）用于标志数据传输已结束。 上图方框部分表示该数据位可能是高电平“1”，也可能是低电平“0”，每一位都有固定的时间宽度，称为位时间。“MARK”表示空闲时高电平，SPACE表示有效电平，这两个术语可以追溯到二十世纪六十年代。 异步串行通信可以是连续的：上一帧的停止位之后立即发送下一帧的起始位；也可以是断续的，新的数据帧可以在任何时刻开始，并不要求整数倍的位时间。 2.同步串行通信 同步串行通信将传输数据按相等的时间间隔划分成数据帧进行传输，并同时发出同步信号以保证收发同步，每个数据帧的开始用同步字符来标志。 同步串行通信要求收发双方的时钟信号（频率、相位等）必须始终同步，且每个数据帧之间不能有间隔，如果线路空闲或没有数据传输，则需发送同步字符串。 同步串行通信的特点是传输效率高，其数据帧大小几乎不受限制（可达几十到几千字节），但因对时钟同步的要求导致硬件实现成本较高，所以同步串行通信一般用于数据量大、对速度要求较高的串行通信场景。 3.主从串行通信 在主从通信系统中至少有一个为主机，并允许有多个主机和多个从机。主机负责发送时钟和仲裁（如片选、广播）信号，从机通过总线仲裁来判定是否与主机通信。 二.串行通信线路 串行通信线路包括单工通信、半双工通信和全双工通信，同步和异步串行通信都可以使用这几种形式： 1.单工通信 单工（Simplex）形式使用一根数据线进行数据的单向传输，通信双方固定一端为发送端，另一端为接收端。 例如，计算机与打印机之间的串行通信就是单工形式，只能有计算机向打印机传输数据，而不能有反向数据。 2.半双工通信 半双工（Harf-duplex）形式的数据传输是双向的，但任何时刻只能由其中一方发送数据，另一方接收数据。半双工形式既可以使用一根数据线，也可以使用两根数据线。下图为一根数据线示例。 3.全双工通信 全双工（Full-duplex）形式的数据传输是双向的，可以同时发送和接收数据，因此全双工形式的串行通信需要两条数据线。 三.串行通信协议 串行通信协议包含对接口电气属性的定义、电路结构及线路连接方式的实现、数据传输性能和传输方式的描述等等，所以也称串行通信协议为串行通信接口或串行通信总线。 在现代MCU内部，基本都集成了一个或多个（相同和不同的）串行通信总线，通过配置寄存器即可实现协议所定义的功能。 1.UART UART（Universal Asynchronous Reciver/Transmitter），通用异步接收器/发送器，也称异步通信接口适配器（ACIA）。UART是最简单的串行通信实现方式。UART出现在电子通信早期，当时是一个由齿轮、继电器和电动机械寄存器组成的机械设备。 一般MCU都集成USART（通用同步和异步接收器/发送器），它可以实现UART和USRT（通用同步接收器/发送器）功能，但在单片机的串行通信中，最常用的是异步方式，因此常把USART写为UART。 异步模式的UART不分主从机，在发送数据的同时可以接收数据。如果在同步模式下，则当使用外部时钟时，UART处于从机地位，当使用内部时钟时，UART处于主机地位。 (1)UART组成 UART由发送缓冲寄存器、接收缓冲寄存器和输入移位寄存器组成，发送缓冲寄存器的本质是一个移位寄存器，它将计算机内的并行数据转换为串行数据，并按配置插入标志位形成数据帧，然后通过Tx接口输出。 接收缓冲寄存器和输入移位寄存器组成双缓冲结构，以避免在数据接收过程中出现数据帧重叠错误。输入移位寄存器将Rx接口输入的串行数据过滤，并转换成并行数据，然后存入接收缓冲寄存器，计算机通过读取接收缓冲寄存器来获得数据。 (2)RS232 RS-232C（简称RS232）是古老的串行通信接口标准，可追溯到20世纪60年代，现在正逐渐被高速网络取代，但它对嵌入式系统来说仍然是一种非常重要、简单而有用的连接工具。RS232通信距离可达25米，传输速度可达38.4kbps。 RS232最开始被用来连接数据终端设备（DTE）和数据通信设备（DCE），因此RS232协议标准默认其一端连接的是DTE，另一端连接的是DCE。在计算机出现之前，DTE是一种电传打字机，DCE是一种调制解调器： 当计算机出现以后，刚开始没有更多的可靠通信接口可选用，于是RS232被应用到计算机当中（计算机既可以作为DTE设备也可以作为DCE设备），并一直沿用到现在。RS232使用DB9（D型9引脚接口）或DB25（D型25引脚接口）作为连接接口，其标准定义参看附录D。 如果单片机与计算机通信则必须将单片机看成DTE或DCE设备，此时需要将单片机UART接口改装成DB9或DB25，然后使用RS232与计算机进行通信。需要注意的是单片机使用的TTL电平与RS232电平不一致，需要进行电平转换（参看附录E）： 当使用UART在两个单片机之间通信时只需对接Tx和Rx接口即可： (3)RS422 RS232传输的数据位的电压电平是相对于本地的地，这种不平衡的传输方式有很差抗噪性。RS422使用双绞线传输数据（见附录G），传输距离可达1200m，双绞线电压差在4V~12V之间，该电压差值范围刚好在RS232逻辑电平范围之内，如果将RS422双绞线中负电压一端接地，则可实现与RS232兼容。（RS422与UART的连接参看附录F）。 注意，RS422只规定了标准电压，而没有像RS232一样规定插脚引线等实现细节，所以RS422的具体实现是未定义的，它可以按照实现者的想法自由连接。 (4)RS485 有些RS422的接口芯片具有三态功能，当RS422使用这种芯片实现时就扩展成为RS485。RS485可以实现高效率、低成本的一主多从式多机通信，并支持许多通信协议。它是最简单和最容易实现的网络之一。 如图，主机和从机之间使用一根双绞线进行通信，所有事务都有主机来初始化，从机只有在接收到特定命令后才进行传输。 2.SPI SPI（Serial Peripheral Interface）串行外围设备接口，是由Motorola公司开发的同步、全双工、一主多从式串行通信总线，常用于微控制器与其外围设备的连接。 (1)SPI组成 SPI有4根信号线：MOSI/SI/SDI（Master Out Slave In）、MISO/SO（Master In Slave Out）、SCLK/SCK、SS/CS。大多数处理器的SPI模块带有片选接口，如果需连接多个从机，则需要使用GPIO。 SPI主机和从机都包含一个（8bit）串行移位寄存器，主机通过写寄存器来通过MOSI信号线发起一次传输，从机同步的将寄存器中的数据通过MISO信号线返回。如果主机仅进行写操作，则忽略收到的字节（数据）即可，如果主机要读取从机一个字节，就必须发送一个空字节来引发从机的传输。 如果主机发送连续的数据流时，有些外设（如存储器）可以进行多字节传输，在这种传输模式下，从机必须在整个传输过程中保持低电平。 (2)SPI时序 根据时钟极性和时钟相位的不同，SPI有四个工作模式以适配不同外设的时序和数据处理需求。时钟极性（CPOL）表示时钟空闲时的状态，时钟相位（CPHA）表示数据采样时的有效性。 当时钟相位为0、时钟极性为低电平时，MISO和MOSI在SCK的上升沿有效。 当时钟相位为0、时钟极性为高电平时，MISO和MOSI在SCK的下降沿有效。 当时钟相位为1、时钟极性为低电平时，MISO和MOSI在SCK的下降沿有效。 当时钟相位为1、时钟极性为高电平时，MISO和MOSI在SCK的上升沿有效。 (3)SPI速度 官方标准没有规定SPI的传输速率，目前已知器件可达Mbps水平。 3.IIC IIC（Inter Integrated Circuit Bus，I2C、I2C、TWI）总线是飞利浦公司（Pilips）开发的同步、全双工、多主多从式串行通信总线，常用于微控制器与其外围设备的连接。 (1)IIC组成 IIC只有2根信号线：SDA串行数据线和SCL串行时钟线；两根线接上拉电阻或正极电源，挂载到IIC总线的（N个）设备通过寻址识别，每个器件都可作为主/从设备，但任何时刻只能有一个主控设备。 (2)IIC速度 IIC标准规定标准速度为100Kbps、快速400Kbps、高速3.4Mbps。 TBD... 2.总线协议 IIC总线有三种信号和两种状态：开始信号、应答信号、停止信号、总线空闲、总线忙碌 附：SDA、SCL默认置高电平状态 开始信号：SCL保持高电平，SDA出现下降沿，表示数据开始传输 应答信号：接收设备收到8bit数据之后，发送一个ACK位给发送设备，且每 8bit数据之后必须有一个应答位 停止信号：SCL保持高电平，SDA出现上升沿，表示数据停止传输 总线空闲：SCL和SDA都处于高电平状态 总线忙碌：开始信号之后，停止信号之前 3.传输格式 IIC总线的传输格式为主从式：主发送从接收、从发送主接收 ·主发送从接收模式 主设备开始信号之后，发送第一个字节为控制字节（从到地址到低地址 = 7位地址寻址位 + 1位方向位，方向位决定主设备是从从设备读数据还是向从设备写数据，为0时表示写、1时表示读），接下来发送数据，该数据可以是一个或N个字节，从设备每接到1个字节都要返回一个应答信号（ACK = 0），主设备在应答时钟周期为高电平时释放SDA，转由从设备控制（发送应答信号），从设备在这个时钟周期的高电平期间必须拉低SDA，并使之为稳定低电平，以作为有效的应答信号 ·从发送主接收模式 仍然从主设备开始信号，主设备向IIC总线发送控制字节（“广播”），从设备进行地址位比对，之后检查控制字节的第8位是1/0，当为1时，表示主控设备要读数据，此时从设备先发送一个应答信号（ACK = 0）给主设备，接着发送数据到主设备，同样的主设备收到一个字节（8bit）后，也要发送一个应答信号给从设备，不同的是如果这个ACK = 0（有效应答信号）那么从设备继续发送数据，如果ACK = 1（停止应答信号）则从设备停止发送数据。主设备也可以控制从设备从什么地址开始发送数据（默认从设备从主设备发送过来的控制字节地址发送数据），发送多少字节 基本操作 IIC总线是主/从双向通信，主设备和从设备都可以发送和接收，但总线必须由主设备控制，主设备产生串行时钟SCL，并产生开始和停止条件，在开始条件之后SDA线上的数据状态仅在SCL为低电平期间内才能改变，在SCL高电平期间SDA上的数据改变用来表示开始和停止条件 ·控制字节 在开始条件之后，第一个字节必须是控制字节，其中高4位是器件类型标识符（不同器件有不同的意义：如EEPROM为1010），接着3位为片选（这意味着同一器件不能超过8个），最低位为读写控制为，即1 - 读/0 - 写 5.总线仲裁 wating... 6.IO模拟 如果单片机带有IIC总线接口（高级单片机一般都带有若干个），则直接挂载设备即可，如果没有，则可以使用普通IO口模拟 ·硬件上 硬件上只需两个GPIO引脚，一个作为串行时钟线SCL，一个作为串行数据线SDA，并且都挂接到上拉电阻或正极电源 ·软件上 软件上要严格模拟IIC总线数据传输规则，示例： 子程序如下： ORG 1000HBSEND: MOV R2, #08H ; 1字节8位 SENDA: CLR P3.2 ; SCL置低 RLC A ; 左移一位 MOV P3.3, C ; 写一位 SETB P3.2 ; SCL置高 DJNZ R2, SENDA ; 写完8个字节？ CLR P3.2 ; 应答信号 SETB P3.3 ; SDA置高 SETB P3.2 ; SCL置低 RETEND 附：MSB与LSB MSB：Most Significant Bit，最高有效位，在时序图中表示高字节先发送或表示最高位，在二进制数中表示最高加权位，位于数据位最左侧 LSB： Least Significant Bit，最低有效位，在时序图中表示低字节先发送或表示最低位，在二进制数中表示最低加权位，位于数据位最右侧 附录A：奇偶校验（Parity check） 奇偶校验是验证数据传输有效性的简单验证方式。一串二进制数据帧，其中“1”的个数只有两种可能：奇数或偶数。 奇校验（ODD CHECK），就是将该数据帧添加一位“0”或“1”，使得新的数据帧中“1”的个数为奇数，新添加的二进制位就是校验位，接收方收到数据后，再次对原数据帧进行奇校验，对比添加的校验位是否一致，如果一致就说明数据完好。 偶校验（EVEN CHECK），就是将该数据帧添加一位“0”或“1”，使得新的数据帧中“1”的个数为偶数，新添加的二进制位就是校验位，接收方收到数据后，再次对原数据进行偶校验，对比添加的校验位是否一致，如果一致就说明数据完好。 奇偶校验，是轻量级数据校验方式，它只适用于数据受干扰较小的情景，如果数据受干扰较大，则二进制数据帧有可能有偶数个数据位变化，导致最后校验结果无误，但实际数据已经损坏。 附录B：波特率与比特率 比特率是指每秒钟传输或处理比特（bit）或位的数量，单位为“bps或bit/s（Bit Per Second）”，常用于计算机通信领域。比特率的单位是千进制：1Kbit/s = 1000bit/s、1Mbit/s = 1000Kbit/s、1Gbit/s = 1000Mbit/s。 每秒1次的信号变化为1波特（baud），原用于表示电信设备传输速率，现用于调制解调器的数据传输速率。波特率是指每秒钟传输符号的数量，单位是波特。通过不同的信号调制方式，可以在一个符号上负载多个比特信息，当调试方式是二进制调制时，波特率与比特率的值一致，单位可使用“bps”等。 附录C：握手（流控） 当两个系统进行串行通信时，在接收者处理完接收数据之前，必须禁止发送者发送新的数据，这个过程称为握手（shake hands）或流控（flow control），握手有三种方式：软件方式、硬件方式、不握手。 不握手是最简单的方式，用于发送系统在准备和发送数据上都比接收系统慢得多的场合，比如1MHz的低速单片机发送给1GHz的高速单片机，或者手工向计算机输入数据。注意，当接收端使用高速处理器，但使用了实时反映能力较弱的操作系统，则也有可能需要握手。 硬件握手方式在不同的硬件中有不同的实现方式，以RS232为例，它使用两个信号：RTS（请求发送）和CTS（清除发送），当发送者希望发送数据时就置RTS有效，高速接收者有数据等待发送，而当接收者准备就绪时就将CTS置为有效，来通知发送者可以发送数据。 软件握手用于无法实现硬件握手的场景。软件握手用两个字符来实现流控，一个代表请求对方暂停传输、另一个代表清除暂停传输的请求，继续传输数据。通常这个两个字符是Ctrl-S（0X13）和Ctrl-Q（0X11）。 附录D：RS232接口（母口）标准 信号 功能 DB25 DB9 方向 Tx 发送数据 2 2 DTE-DCE Rx 接收数据 3 3 DTE-DCE RTS 请求发送 4 7 DTE-DCE CTS 清除发送 5 8 DTE-DCE DTR 数据终端就绪 20 4 DTE-DCE DSR 数据设备就绪 6 6 DTE-DCE DCD 数据载波检测 8 1 DTE-DCE RI 振铃指示器 22 1 DTE-DCE FG 侦测地（机壳） 1 - 共用 SG 信号地 7 5 共用 注：① DB25和DB9接口呈“D”型，它们又被称为COM口；② 这些信号中许多都是用来对调试解调器进行控制器的，如果要在一台计算机和一个终端之间建立一个很简单的链接，仅需Tx和Rx信号就够了。另外，许多系统都将FG和SG连接到一起。 附录E：UART转RS232（DB9） TTL逻辑高电平为：输出 - >2.4V，输入 - >2.0V；逻辑低电平为：输出 - MAX232支持两个输入输出端口：T1IN、T2IN、T1OUT、T2OUT、R1IN、R2IN、R1OUT、R2OUT；通过附录D可知，DB9第2和3针为Rx、Tx，第5针为SG信号地（必要）： 注：① DB9有公头和母头之分，它们的引脚顺序定义不同，且母头的第一引脚在右上角（倒梯形时），其它引脚依次向左排列；② 没有用到的接口，可以用作嵌入式系统的电源线；③ 与PC通信时，波特率不宜设置太高，以免有乱码出现。 附录F：UART转RS422 MAX3488是一款用于RS422电平转换的芯片，同RS232一样，其Tx和Rx接口可直接与UART相连： 上图中Rt是一个终止电阻，用来消除信号反射，信号反射发生在远距离传输过程中，并且是远距离传输所必须的。Rt的标准阻值是100~120Ω。 附录G：共模抑制 用两根线之间的电压差来代表逻辑电平，这两根线称为双绞线或差分对（different pair），两个信号振幅相等、相位相反，当出现噪声时，双绞线同时受到干扰，于是两根线之间的电压差几乎没有变化，这种现象又称为共模抑制。 "},"pages/Qt.html":{"url":"pages/Qt.html","title":"Qt","keywords":"","body":"1.μC-GUI与emWin μC-GUI和emWin都是嵌入式系统图形库，emWin由Segger公司研发，μC-GUI是Segger面向Micrium公司的定制产品，两款产品资料通用，但拥有各自的使用许可条文。 2.μC-GUI Micrium公司的所有产品，在任何商业应用条件下都不是免费的，并且对所有产品拥有统一的在商业中使用的许可条文： ①单一产品许可：需指定CPU型号，最终产品名称，没有数量和时间限制 ②产品线许可：无需指定CPU型号，需指定最终产品名称 ③CPU类型（平台）许可：只需指定CPU型号，可以生产各种产品 ④站点许可：只需指定站点，CPU、最终产品名称和数量都没有限制 价格表（Micrium中国总代 - 北京麦克泰软件技术有限公司，μC-GUI报价）： 类型 价格（元） 时间 单一产品许可 RMB130,000 永久 产品线许可 RMB650,000 永久 CPU类型（平台）许可 RMB845,000 永久 站点许可 - - 3.emWin Segger公司的产品，在商业应用条件下有免费使用方式： ① Segger公司提供定制服务，定制公司用于产品最终解释权，如Segger向ST公司定制STemWin，则使用含有STemWin库的ST芯片时无需支付库的使用费用；而Segger向Micrium公司定制μC-GUI，但使用μC-GUI时需要遵循Micrium公司许可条款。 ② Segger公司提供合作机制，如Segger与NXP公司合作，凡使用NXP芯片的用户，都可以免费使用emWin库（信息来源：https://www.nxp.com/pages/emwin-graphics-library:EMWIN-GRAPHICS-LIBRARY）。 附录A：Micrium 总部（美）联系方式 ·电话：1-954-217-2036 ·传真：1-954-217-2037 ·邮箱： 销售邮箱：sales@micrium.com 信息咨询：info@micrium.com ·官网：https://www.micrium.com/ "},"pages/Bootloader.html":{"url":"pages/Bootloader.html","title":"Bootloader","keywords":"","body":"uboot简介 uboot是GNU开源、嵌入式领域的Bootloader，用于初始化硬件和加载内核（加载模式），并提供基础命令行环境以调试硬件和下载程序（开发模式）。 官网：http://www.denx.de；（下载）ftp://ftp.denx.de/pub/u-boot/。 uboot分析 1.版本分析 uboot分为官网版本、Soc厂商版本和第三方版本。 官网uboot每年约2~3个月发布一个版本，到2017年为止大约有70个版本，可分为三个阶段：初阶段版本-2010.6（不含）之前的版本，中阶段版本-2010.6~2014.10（不含）之间的版本，现阶段版本-2014.10以后的版本。各版本间主要有以下变化： 版本号变化：2008年8月以前的版本按版本号命名，其后按年份命名 目录树变化：第一次从u-boot-1.3.2版本增加了“api”目录，第二次从2010.6版 本合并了“cpu”与“lib_xxx”目录到“arch”目录，并分离出通用的“lib”目录。 配置的变化：从2014.10版本开始支持图形界面配置“$make menuconfig” Soc厂商uboot从官网uboot移植以支持其Soc和核心PCB，第三方一般是PCB底板厂商，其uboot从Soc厂商移植以支持其底板PCB。 2.目录分析 u-boot-2019.07版本uboot有1630个目录、21757个文件，其主要目录结构及含义如下： 附：参考目录树，u-boot-2019.07版本示例 ├── api Machine/arch independent API for external apps [用于外部应用程序的独立于机器/架构的API] ├── arch Architecture specific files ├── board Board dependent files ├── cmd U-Boot commands functions ├── common Miscellaneous architecture independent functions [混杂的独立于体系结构的功能] ├── configs Board default configuration files ├── disk Code for disk drive partition handling ├── doc ├── Documentation ├── drivers Commonly used device drivers ├── dts Contains Makefile for building internal U-Boot fdt [flatted device tree - 设备扁平树] ├── env├── examples ├── fs Filesystem code (cramfs, ext2, jffs2, etc.) ├── include Header Files ├── lib Library routines generic to all architectures [所有体系结构通用的库例程] ├── Licenses ├── net Networking code ├── post Power On Self Test ├── scripts Various build scripts and Makefiles ├── test └── tools Tools to build S-Record or U-Boot images, etc 3.编译原理 uboot编译依赖于Makefile技术。在u-boot-2014.10版本之前，编译主要依赖顶层目录的“Makefile”、“config.mk”及各子孙目录的“Makefile”文件。在u-boot-2014.10版本之后，增加了图形界面，其编译除依赖上述文件外还依赖“Kconfig”文件。 //TBD uboot编写 uboot移植 编译 移植的最终目的是生成“uboot.bin”二进制文件，其 //TBD 附录A：BIOS BIOS（Basic Input Output System）基本输入输出系统是固化在ROM芯片内、（PC）上电后执行的第一个程序，用于开机自检（POST）、硬件配置等最底层的硬件控制。 通过BIOS可以指定Bootloader启动介质，从而进一步启动操作系统。嵌入式系统中通常使用简单的拨码方式代替BIOS的该项功能。 附录B：BootLoader Bootloader（启动加载器）是一种引导程序，用于初始化硬件和加载操作系统内核，是计算机上电后执行的第一个或第二个程序（第一个是BIOS）。 Bootloader与硬件相关，因此都集成了很多平台，PC端有适用Linux的Lilo/Grub、适用Windows的NTLDR。嵌入式端有红帽的Redboot、ARM的blob/ARMboot、三星的vivi/Bios-it、GNU的uboot等等。 附录C：uboot（Hush-shell）命令 "},"pages/Analog.html":{"url":"pages/Analog.html","title":"Analog Elec","keywords":"","body":"concept 模拟电子技术（Analog Electronics Tec.）是以半导体为基础材料、以电荷移动为基本原理的模拟信号放大技术。本质是研究能量的控制，结果是功率（不失真）的放大 电子技术的发展 关键词：电子管-晶体管-集成电路-大规模-超大规模 ---------------------------------------------- 1947 晶体管 - 贝尔实验室 1958 集成电路 1969 大规模集成电路 1975 超大规模集成电路 第一片集成电路只有4个晶体管，1997年有40亿个 预计2020年达饱和 模拟信号与模拟电路 关键词：连续/时间&空间有意义/放大（能量控制）/有源元件/功能和性能(细节)分析 --------------------------------------------------------------------------- 重点：基本概念/基本电路/基本分析方法/全面分析(副作用分析），适用的才是最好的 -------------------------------------------------------------------------- 四个会：会看(读图/分析)/会算/会选(电路 器件 参数)/会调 ----------------------------------------------------- 数字信号：离散性（时间和数值） 模拟信号：连续性（时间和数值），几乎所有物理量都是模拟信号，如温度 压力等，任何瞬间的任何值都有意义 模拟电路：最基本的处理是对信号的放大，放大的本质是能量的控制 传感器/AD转化的信号基本上都是小信号，它们不足以驱动负载/传输/转化，所以要进行放大 有源元件：能够控制能量的元件 常用半导体器件 半导体基础知识 本征半导体 半导体：绝缘体 mid 导体 导体的最外层电子容易脱离原子核束缚（通过电场/温度等）, 最外层电子4 半导体-四价元素，Si Ge，电子被束缚力介于导体与绝缘体之间 最外层电子=4 原子核：正电 电子：负电 关键词：原子结构（核正子负，最外2/8稳定，4为半导体，其它结构易失/得）/Si Ge/本征无杂质-共价键 拓展 : 化学-原子 ---------------- 关键词：少子/多子 载流子 自由电子/空穴 热运动 (绝对温度0度不导电） 拓展：物理 - 热力学 ------------------ 本征半导体受温度影响 自由电子脱离共价键束缚成为自由电子 形成空穴 在温度一定下，自由电子浓度一定 温度升高，热运动加剧 杂质半导体 本征半导体受电场和温度影响，载流子很少，导电性很差 参如3价和5价的元素掺入本征半导体，将改善导电性能 N型半导体：本征加入P磷，破坏共价键，增加一个P就增加一个自由电子，此时自由电子成为多数载流子,空穴为少数 P : B硼, 吸收电子 , 空穴成为多数载流子，自由电子为少数 关键词：5价/P磷/3价/B硼/N型半导体(Negative -)/P型半导体（Positive +） 杂质半导体，仍然受温度变化，但受温度变化自由电子和空穴浓度仍然一定，重要的是在N中空穴比例小，温度变化 后对空穴比例浓度影响最大，P中自由电子比例小，温度变化后自由电子比例浓度影响较大 重点：少数载流子是影响半导体器件温度稳定性的主要因素 关键词：温度/比例浓度 PN结的形成及其单向导电性 在一块本征半导体基片上，做成PN结(两端根据扩散原理掺入不同杂质)，注意，不是将一个P半导体和N半导体按压到一起！！ ,这样它们的交界界面就形成空间电荷区，成为PN结 制作成的PN结，仍然受扩散运动的影响，P区的空穴向N区扩散，N区的自由电子向P区扩散， （实际上空穴是假想，实际是电子运动) NONE P N ----------- | +++++++++ | |-----------| ----------- | +++++++++ | |-----------| ----------- | +++++++++ | |-----------| N区电子运动到P区与空穴复合，因为复合后P区接触面开始带负电，N区开始带正电，导致PN结形成内电场 内电场将组织自由电子的复合，并且反向运动，如此反复以形成稳定的区域 NONE P N ----------- | +++++++++ | |-----------| ----------- | +++++++++ | |-----------| ----------- | +++++++++ | |-----------| 在空间电荷区（接触面）N区的自由电子向 关键词：空间电荷区/PN结-扩散运动-内电场-漂移运动-动态平衡 -------------------------------------------------------- 拓展：物理-热力学 ---------------- 给PN结通电，会打破动态平衡，释加正电压会削弱内电场（耗尽层变窄），进而扩散运动加剧，PN导通 正电压是指P区接正极，N接负极，因为电流的流动实际是电子的移动，即从电池的负极流出电子，而 负极接N区，导致N区电子增多，进而削弱了内电场，最后导通PN结 如果反向给电，效果相反，即电池的电子流向了P区，使得复合了很多空穴，增加了内电场，使得耗尽区变大，PN不通 关键词：外电场/削弱-增强/导通-截止/耗尽区/正向-加剧扩散/反向-加剧漂移 --------------------------------------------------------------------- 拓展：物理 - 电荷运动 -------------------- PN结的电容效应 势垒电容 : PN结外加电压时 空间电荷区宽度变化，有电荷积累和释放过程，与电容充放电向相同，其等效电容为//// 扩散电容： PN结外加正电压时，在扩散过程中在刘子浓度和梯度都有变化，也有电荷累积和释放，其等。。。。 结电容 =势垒电容 + 扩散电容 结电容不是常量，PN结外加电压频率到一定程度将失去单向导电性 关键词：势垒电容 扩散电容 结电容 限制电压频率 总之，pn结的扩散电容与其势垒电容不同。前者是少数载流子引起的电容，对于pn结的开关速度有很大影响，在正偏下起很大作用、在反偏下可以忽略，在低频时很重要、在高频时可以忽略；后者是多数载流子引起的电容，在反偏和正偏时都起作用，并且在低频和高频下都很重要 二极管 "},"pages/PCB.html":{"url":"pages/PCB.html","title":"PCB Design","keywords":"","body":"CHAPTER 一. PCB基础 1.简介 PCB（Printed Circuit Board） 印制电路板，简称电路板。PCB是电子元器件的电气连接载体和支撑体，在20世纪50年代开始推广，是现代广泛采用的电路构建技术。 附录A：古老的电路构建方式。 2.分类 3.组成 TBD Q&A PCB有好多类型层、如何知道设计一个PCB应该包含哪些层？需要哪些层？ CHAPTER 二. PCB画板 附录A：古老的电路构建方式 1.快速构建 这是一种非常草率的方法，只对构造极其简单的电路原型有用。它通过在任意大小的空间里把元器件焊接在一起来构成非常简单的电路。 如图，将晶体放在处理器上方，晶体引线直接焊接到处理器引脚，其它引线也焊接到处理器引脚来引入电源和接地从而把处理器的I/O和外部连接起来。 2.面包板 面包板又称电路实验板，是带有排列孔的塑料块儿，它被设计用来盛放DIP封装（双列直插封装）的集成电路和离散元器件。术语“面包板”可追溯到真空管时代，当时真空管无线电设备是建立在一块用于切面包的结实木板上的，因此得名。 使用面包板也不是搭建健壮可靠系统的方法，面包板限制于过多的电容、串扰及噪声敏感度，长期使用后还有机器故障。面包板上的电路连接是通过一段段小的电线来实现的，而这些电线构成了小的天线，这些小天线会吸收周围零散的电磁辐射从而影响电路。 3.绕接技术 绕接曾经是常用的电路构建技术，必须是DIP封装的电路才能使用绕接，它通过约0.6英寸的引脚安装在插座上，然后用绕砸工具（绕砸器和剥线器）在引脚周围绕上电线，这样便构成了一个电路，这也被称为冷焊技术，即不带焊接的一种线与引脚间的紧密电气连接技术。 绕接是一种非常快速的原型技术，且健壮和可靠。在早期，NASA（美国国家航天局）惯于使用绕接技术构建宇宙飞船电子设备，并且许多大型计算机也使用这种技术。 "}}